<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rivgraph.mask_to_graph &mdash; RivGraph 0.4 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/rg_logo_full.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.4
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../background/index.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maskmaking/index.html">Maskmaking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shoreline/index.html">Shoreline creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../linksnodes/index.html">Link and Node Dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../issues/index.html">Known issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../featuredevelopment/index.html">Feature Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">RivGraph in the wild</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apiref/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">RivGraph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../index.html">Module code</a> &raquo;</li>
      <li>rivgraph.mask_to_graph</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for rivgraph.mask_to_graph</h1><div class="highlight"><pre>
<span></span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">Mask to Graph Utilities (mask_to_graph.py)</span>
<span class="sd">==========================================</span>

<span class="sd">Functions for converting a binary channel mask to a graphical representation.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">from</span> <span class="nn">loguru</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="kn">import</span> <span class="nn">cv2</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">skimage</span> <span class="kn">import</span> <span class="n">morphology</span><span class="p">,</span> <span class="n">measure</span>
<span class="kn">from</span> <span class="nn">rivgraph</span> <span class="kn">import</span> <span class="n">walk</span>
<span class="kn">import</span> <span class="nn">rivgraph.ln_utils</span> <span class="k">as</span> <span class="nn">lnu</span>
<span class="kn">import</span> <span class="nn">rivgraph.im_utils</span> <span class="k">as</span> <span class="nn">imu</span>
<span class="kn">from</span> <span class="nn">rivgraph.ordered_set</span> <span class="kn">import</span> <span class="n">OrderedSet</span>


<div class="viewcode-block" id="skel_to_graph"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.mask_to_graph.skel_to_graph">[docs]</a><span class="k">def</span> <span class="nf">skel_to_graph</span><span class="p">(</span><span class="n">Iskel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Resolves a skeleton into its consitutent links and nodes.</span>
<span class="sd">    This function finds a starting point to walk along a skeleton, then begins</span>
<span class="sd">    the walk. Rules are in place to ensure the network is fully resolved. One</span>
<span class="sd">    of the key algorithms called by this function involves the identfication of</span>
<span class="sd">    branchpoints in a way that eliminates unnecessary ones to create a parsimonious</span>
<span class="sd">    network. Rules are baked in for how to walk along the skeleton in cases</span>
<span class="sd">    where multiple branchpoints are clustered or there are multiple possible</span>
<span class="sd">    links to walk along.</span>

<span class="sd">    Note that some minor adjustments to the skeleton may be made in order to</span>
<span class="sd">    reduce the complexity of the network. For example, in the case of a &quot;+&quot;</span>
<span class="sd">    with a missing center pixel in the skeleton, this function will add the</span>
<span class="sd">    pixel to the center to enable the use of a single branchpoint as opposed to</span>
<span class="sd">    four.</span>

<span class="sd">    The takeaway is that there is no guarantee that the input skeleton will</span>
<span class="sd">    be perfectly preserved when network-ifying. One possible workaround, if</span>
<span class="sd">    perfect preservation is required, is to resample the skeleton to double the</span>
<span class="sd">    resolution.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Iskel : np.ndarray</span>
<span class="sd">        Binary image of a skeleton.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    links : dict</span>
<span class="sd">        Links of the network with four properties:</span>

<span class="sd">        1. &#39;id&#39; - a list of unique ids for each link in the network</span>

<span class="sd">        2. &#39;idx&#39; - a list containing the pixel indices within Iskel that defines the link. These are ordered.</span>

<span class="sd">        3. &#39;conn&#39; - a list of 2-element lists containing the node ids that the link is connected to.</span>

<span class="sd">        4. &#39;n_networks&#39; - the number of disconnected networks found in the skeleton</span>

<span class="sd">    nodes : dict</span>
<span class="sd">        Nodes of the network with four properties:</span>

<span class="sd">        1. &#39;id&#39; - a list of unique ids for each node in the network</span>

<span class="sd">        2. &#39;idx&#39; - the index within Iskel of the node location</span>

<span class="sd">        3. &#39;conn&#39; - a list of lists containing the link ids connected to this node</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">check_startpoint</span><span class="p">(</span><span class="n">spidx</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns True if a skeleton pixel&#39;s first neighbor is not a branchpoint</span>
<span class="sd">        (i.e. the start pixel is valid for a walk), else returns False.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        spidx : int</span>
<span class="sd">            Index within Iskel of the point to check.</span>
<span class="sd">        Iskel : np.array</span>
<span class="sd">            Image of skeletonized mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        chk_sp : bool</span>
<span class="sd">            True if the startpoint is valid; else False.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">neighs</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">walkable_neighbors</span><span class="p">([</span><span class="n">spidx</span><span class="p">],</span> <span class="n">Iskel</span><span class="p">)</span>
        <span class="n">isbp</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">is_bp</span><span class="p">(</span><span class="n">neighs</span><span class="o">.</span><span class="n">pop</span><span class="p">(),</span> <span class="n">Iskel</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">isbp</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">chk_sp</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">chk_sp</span> <span class="o">=</span> <span class="kc">False</span>

        <span class="k">return</span> <span class="n">chk_sp</span>


    <span class="k">def</span> <span class="nf">find_starting_pixels</span><span class="p">(</span><span class="n">Iskel</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds an endpoint pixel to begin walking to resolve network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        Iskel : np.array</span>
<span class="sd">            Image of skeletonized mask.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        startpoints : list</span>
<span class="sd">            Possible starting points for the walk.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get skeleton connectivity</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">skel_endpoints</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>
        <span class="n">eps</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">(</span><span class="n">eps</span><span class="p">,</span> <span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>

        <span class="c1"># Get one endpoint per connected component in network</span>
        <span class="n">rp</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">regionprops</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">])</span>
        <span class="n">startpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ni</span> <span class="ow">in</span> <span class="n">rp</span><span class="p">[</span><span class="s1">&#39;coords&#39;</span><span class="p">]:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="nb">set</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ravel_multi_index</span><span class="p">((</span><span class="n">ni</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">ni</span><span class="p">[:,</span><span class="mi">1</span><span class="p">]),</span> <span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
            <span class="c1"># Find a valid endpoint for each connected component network</span>
            <span class="n">poss_id</span> <span class="o">=</span> <span class="n">idcs</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poss_id</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">pid</span> <span class="ow">in</span> <span class="n">poss_id</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">check_startpoint</span><span class="p">(</span><span class="n">pid</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                        <span class="n">startpoints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pid</span><span class="p">)</span>
                        <span class="k">break</span>

        <span class="k">return</span> <span class="n">startpoints</span>

    <span class="c1"># Pad the skeleton image to avoid edge problems when walking along skeleton</span>
    <span class="n">initial_dims</span> <span class="o">=</span> <span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">npad</span> <span class="o">=</span> <span class="mi">20</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">npad</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">dims</span> <span class="o">=</span> <span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span>

    <span class="c1"># Find starting points of all the networks in Iskel</span>
    <span class="n">startpoints</span> <span class="o">=</span> <span class="n">find_starting_pixels</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Initialize topology storage vars</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">([])</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>

    <span class="n">links</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
    <span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="n">links</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[[]]</span>
    <span class="n">links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">([])</span>

    <span class="c1"># Initialize first links emanting from all starting points</span>
    <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sp</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">startpoints</span><span class="p">):</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]),</span> <span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">node_updater</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">sp</span><span class="p">,</span> <span class="n">i</span><span class="p">)</span>
        <span class="n">first_step</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">walkable_neighbors</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">],</span> <span class="n">Iskel</span><span class="p">)</span>
        <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">first_step</span><span class="o">.</span><span class="n">pop</span><span class="p">())</span>

    <span class="n">links</span><span class="p">[</span><span class="s1">&#39;n_networks&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">i</span><span class="o">+</span><span class="mi">1</span>

    <span class="c1"># Initialize set of links to be resolved</span>
    <span class="n">links2do</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>

    <span class="k">while</span> <span class="n">links2do</span><span class="p">:</span>

        <span class="n">linkid</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="nb">iter</span><span class="p">(</span><span class="n">links2do</span><span class="p">))</span>
        <span class="n">linkidx</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">linkid</span><span class="p">)</span>

        <span class="n">walking</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="n">cantwalk</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">cant_walk</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">linkidx</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">)</span>

        <span class="k">while</span> <span class="n">walking</span><span class="p">:</span>

            <span class="c1"># Get next possible steps</span>
            <span class="n">poss_steps</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">walkable_neighbors</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">],</span> <span class="n">Iskel</span><span class="p">)</span>

            <span class="c1"># Now we have a few possible cases:</span>
            <span class="c1"># 1) endpoint reached,</span>
            <span class="c1"># 2) only one pixel to walk to: must check if it&#39;s a branchpoint so walk can terminate</span>
            <span class="c1"># 3) two pixels to walk to: if neither is branchpoint, problem in skeleton. If one is branchpoint, walk to it and terminate link. If both are branchpoints, walk to the one that is 4-connected.</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poss_steps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># endpoint reached, update node, link connectivity</span>
                <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">node_updater</span><span class="p">(</span><span class="n">nodes</span><span class="p">,</span> <span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">linkid</span><span class="p">)</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">linkid</span><span class="p">,</span> <span class="n">conn</span><span class="o">=</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">links2do</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">linkid</span><span class="p">)</span>
                <span class="k">break</span> <span class="c1"># must break rather than set walking to 0 as we don&#39;t want to execute the rest of the code</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">])</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">:</span>
                <span class="n">poss_steps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">poss_steps</span> <span class="o">-</span> <span class="n">cantwalk</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">poss_steps</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">poss_steps</span><span class="p">)</span>

            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">poss_steps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span> <span class="c1"># We have reached an emanating link, so delete the current one we&#39;re working on</span>
                <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">delete_link</span><span class="p">(</span><span class="n">linkid</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>
                <span class="n">links2do</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="n">linkid</span><span class="p">)</span>
                <span class="n">walking</span> <span class="o">=</span> <span class="mi">0</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">poss_steps</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Only one option, so we&#39;ll take the step</span>
                <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">linkid</span><span class="p">,</span> <span class="n">poss_steps</span><span class="p">)</span>

                <span class="c1"># But check if it&#39;s a branchpoint, and if so, stop marching along this link and resolve all the branchpoint links</span>
                <span class="k">if</span> <span class="n">walk</span><span class="o">.</span><span class="n">is_bp</span><span class="p">(</span><span class="n">poss_steps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Iskel</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">handle_bp</span><span class="p">(</span><span class="n">linkid</span><span class="p">,</span> <span class="n">poss_steps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">links2do</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">)</span>
                    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">check_dup_links</span><span class="p">(</span><span class="n">linkid</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span><span class="p">)</span>
                    <span class="n">walking</span> <span class="o">=</span> <span class="mi">0</span> <span class="c1"># on to next link</span>

            <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">poss_steps</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span> <span class="c1"># Check to see if either/both/none are branchpoints</span>
                <span class="n">isbp</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">poss_steps</span><span class="p">:</span>
                    <span class="n">isbp</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">walk</span><span class="o">.</span><span class="n">is_bp</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">))</span>

                <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">isbp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>

                    <span class="c1"># Compute 4-connected neighbors</span>
                    <span class="n">isfourconn</span> <span class="o">=</span> <span class="p">[]</span>
                    <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span>  <span class="n">poss_steps</span><span class="p">:</span>
                        <span class="n">checkfour</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ps</span>
                        <span class="k">if</span> <span class="n">checkfour</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                            <span class="n">isfourconn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">isfourconn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                    <span class="c1"># Compute noturn neighbors</span>
                    <span class="n">noturn</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">idcs_no_turnaround</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">][</span><span class="o">-</span><span class="mi">2</span><span class="p">:],</span> <span class="n">Iskel</span><span class="p">)</span>
                    <span class="n">noturnidx</span> <span class="o">=</span> <span class="p">[</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">noturn</span> <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">poss_steps</span><span class="p">]</span>

                    <span class="c1"># If we can walk to a 4-connected pixel, we will</span>
                    <span class="k">if</span> <span class="nb">sum</span><span class="p">(</span><span class="n">isfourconn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">linkid</span><span class="p">,</span> <span class="n">poss_steps</span><span class="p">[</span><span class="n">isfourconn</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
                    <span class="c1"># If we can&#39;t walk to a 4-connected, try to walk in a direction that does not turn us around</span>
                    <span class="k">elif</span> <span class="nb">len</span><span class="p">(</span><span class="n">noturnidx</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">linkid</span><span class="p">,</span> <span class="n">noturnidx</span><span class="p">)</span>
                    <span class="c1"># Else, shit. You&#39;ve found a critical flaw in the algorithm.</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;idx: </span><span class="si">{}</span><span class="s1">, poss_steps: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">poss_steps</span><span class="p">))</span>
                        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Ambiguous which step to take next :( Please raise issue at https://github.com/jonschwenk/RivGraph/issues.&#39;</span><span class="p">)</span>

                <span class="k">elif</span> <span class="nb">sum</span><span class="p">(</span><span class="n">isbp</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="c1"># If we&#39;ve already accounted for this branchpoint, delete the link and halt</span>
                    <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">linkid</span><span class="p">,</span> <span class="n">poss_steps</span><span class="p">[</span><span class="n">isbp</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)])</span>
                    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">handle_bp</span><span class="p">(</span><span class="n">linkid</span><span class="p">,</span> <span class="n">poss_steps</span><span class="p">[</span><span class="n">isbp</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="mi">1</span><span class="p">)],</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">links2do</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">)</span>
                    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">check_dup_links</span><span class="p">(</span><span class="n">linkid</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span><span class="p">)</span>
                    <span class="n">walking</span> <span class="o">=</span> <span class="mi">0</span>

                <span class="k">elif</span> <span class="nb">sum</span><span class="p">(</span><span class="n">isbp</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># In the case where we can walk to more than one branchpoint, choose the</span>
                        <span class="c1"># one that is 4-connected, as this is how we&#39;ve designed branchpoint</span>
                        <span class="c1"># assignment for complete network resolution.</span>
                        <span class="n">isfourconn</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">ps</span> <span class="ow">in</span>  <span class="n">poss_steps</span><span class="p">:</span>
                            <span class="n">checkfour</span> <span class="o">=</span> <span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ps</span>
                            <span class="k">if</span> <span class="n">checkfour</span> <span class="ow">in</span> <span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="o">-</span><span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="p">[</span><span class="mi">1</span><span class="p">]]:</span>
                                <span class="n">isfourconn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">isfourconn</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>

                        <span class="c1"># Find poss_step(s) that is both 4-connected and a branchpoint</span>
                        <span class="n">isbp_and_fourconn_idx</span> <span class="o">=</span> <span class="p">[</span><span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">isbp</span><span class="p">))</span> <span class="k">if</span> <span class="n">isbp</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">isfourconn</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">==</span><span class="mi">1</span><span class="p">]</span>

                        <span class="c1"># If we don&#39;t have exactly one, shit.</span>
                        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">isbp_and_fourconn_idx</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;idx: </span><span class="si">{}</span><span class="s1">, poss_steps: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">linkidx</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">poss_steps</span><span class="p">))</span>
                            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;There is not a unique branchpoint to step to.&#39;</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_updater</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">linkid</span><span class="p">,</span> <span class="n">poss_steps</span><span class="p">[</span><span class="n">isbp_and_fourconn_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]])</span>
                            <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">handle_bp</span><span class="p">(</span><span class="n">linkid</span><span class="p">,</span> <span class="n">poss_steps</span><span class="p">[</span><span class="n">isbp_and_fourconn_idx</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">links2do</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">)</span>
                            <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span> <span class="o">=</span> <span class="n">walk</span><span class="o">.</span><span class="n">check_dup_links</span><span class="p">(</span><span class="n">linkid</span><span class="p">,</span> <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">links2do</span><span class="p">)</span>
                            <span class="n">walking</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># Put the link and node coordinates back into the unpadded</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">adjust_for_padding</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">npad</span><span class="p">,</span> <span class="n">dims</span><span class="p">,</span> <span class="n">initial_dims</span><span class="p">)</span>

    <span class="c1"># Add indices to nodes--this probably should&#39;ve been done in network extraction</span>
    <span class="c1"># but since nodes have unique idx it was unnecessary.</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">OrderedSet</span><span class="p">(</span><span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">])))</span>

    <span class="c1"># Remove duplicate links if they exist; for some single-pixel links,</span>
    <span class="c1"># duplicates are formed. Ideally the walking code should ensure that this</span>
    <span class="c1"># doesn&#39;t happen, but for now removing duplicates suffices.</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">remove_duplicate_links</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="skeletonize_mask"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.mask_to_graph.skeletonize_mask">[docs]</a><span class="k">def</span> <span class="nf">skeletonize_mask</span><span class="p">(</span><span class="n">Imask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Skeletonizes an input binary image, typically a mask. Also performs some</span>
<span class="sd">    skeleton simplification by (1) removing pixels that don&#39;t alter connectivity,</span>
<span class="sd">    and (2) filling small skeleton holes and reskeletonizing.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Imask : np.array</span>
<span class="sd">        Binary image to be skeletonized.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Iskel : np.array</span>
<span class="sd">        The skeletonization of Imask.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Create copy of mask to skeletonize</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Imask</span><span class="p">,</span> <span class="n">copy</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;bool&#39;</span><span class="p">)</span>

    <span class="c1"># Perform skeletonization</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Simplify the skeleton (i.e. remove pixels that don&#39;t alter connectivity)</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">simplify_skel</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Fill small skeleton holes, re-skeletonize, and re-simplify</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">maxholesize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">simplify_skel</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Fill single pixel holes</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">maxholesize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Iskel</span></div>


<div class="viewcode-block" id="skeletonize_river_mask"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.mask_to_graph.skeletonize_river_mask">[docs]</a><span class="k">def</span> <span class="nf">skeletonize_river_mask</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">padscale</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Skeletonizes a binary mask of a river channel network. Differs from</span>
<span class="sd">    skeletonize mask above by using knowledge of the exit sides of the river</span>
<span class="sd">    with respect to the mask (I) to avoid edge effects of skeletonization by</span>
<span class="sd">    mirroring the mask at its ends, then trimming it after processing. As with</span>
<span class="sd">    skeletonize_mask, skeleton simplification is performed.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : np.array</span>
<span class="sd">        Binary river mask to skeletonize.</span>
<span class="sd">    es : str</span>
<span class="sd">        A two-character string (from N, E, S, or W) that denotes which sides</span>
<span class="sd">        of the image the river intersects (upstream first) -- e.g. &#39;NS&#39;, &#39;EW&#39;,</span>
<span class="sd">        &#39;NW&#39;, etc.</span>
<span class="sd">    padscale : int, optional</span>
<span class="sd">        Pad multiplier that sets the size of the padding. Multplies the blob</span>
<span class="sd">        size along the axis of the image that the blob intersect to determine</span>
<span class="sd">        the padding distance. The default is 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Iskel : np.array</span>
<span class="sd">        The skeletonization of I.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Crop image</span>
    <span class="n">Ic</span><span class="p">,</span> <span class="n">crop_pads</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">crop_binary_im</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

    <span class="c1"># Pad image (reflects channels at image edges)</span>
    <span class="n">Ip</span><span class="p">,</span> <span class="n">pads</span> <span class="o">=</span> <span class="n">pad_river_im</span><span class="p">(</span><span class="n">Ic</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">pm</span><span class="o">=</span><span class="n">padscale</span><span class="p">)</span>

    <span class="c1"># Skeletonize padded image</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">Ip</span><span class="p">)</span>

    <span class="c1"># Remove padding</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">Iskel</span><span class="p">[</span><span class="n">pads</span><span class="p">[</span><span class="mi">0</span><span class="p">]:</span><span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">pads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">pads</span><span class="p">[</span><span class="mi">3</span><span class="p">]:</span><span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">pads</span><span class="p">[</span><span class="mi">2</span><span class="p">]]</span>
    <span class="c1"># Add back what was cropped so skeleton image is original size</span>
    <span class="n">crop_pads_add</span> <span class="o">=</span> <span class="p">((</span><span class="n">crop_pads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">crop_pads</span><span class="p">[</span><span class="mi">3</span><span class="p">]),(</span><span class="n">crop_pads</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">crop_pads</span><span class="p">[</span><span class="mi">2</span><span class="p">]))</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">pad</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">crop_pads_add</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;constant&#39;</span><span class="p">,</span> <span class="n">constant_values</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">))</span>

    <span class="c1"># Ensure skeleton is prepared for analysis by RivGraph</span>
    <span class="c1"># Simplify the skeleton (i.e. remove pixels that don&#39;t alter connectivity)</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">simplify_skel</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Fill small skeleton holes, re-skeletonize, and re-simplify</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">maxholesize</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">morphology</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">simplify_skel</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Fill single pixel holes</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">maxholesize</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="c1"># The handling of edges can leave pieces of the skeleton stranded (i.e.</span>
    <span class="c1"># disconnected from the main skeleton). Remove those here by keeping the</span>
    <span class="c1"># largest blob.</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Iskel</span></div>


<div class="viewcode-block" id="simplify_skel"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.mask_to_graph.simplify_skel">[docs]</a><span class="k">def</span> <span class="nf">simplify_skel</span><span class="p">(</span><span class="n">Iskel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    This function iterates through all skeleton pixels pixels that have</span>
<span class="sd">    connectivity &gt; 2. It removes the pixel and checks if the</span>
<span class="sd">    number of blobs has changed after removal. If so, the pixel is necessary to</span>
<span class="sd">    maintain connectivity. Otherwise the pixel is not retained. It also adds</span>
<span class="sd">    pixels to the centers of &quot;+&quot; cases, as this reduces the number</span>
<span class="sd">    of branchpoints from 4 to 1.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Iskel : np.array</span>
<span class="sd">        Image of the skeleton to simplify.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Iskel : np.array</span>
<span class="sd">        The simplified skeleton.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Iskel</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">Ic</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">im_connectivity</span><span class="p">(</span><span class="n">Iskel</span><span class="p">)</span>
    <span class="n">ypix</span><span class="p">,</span> <span class="n">xpix</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ic</span> <span class="o">&gt;</span> <span class="mi">2</span><span class="p">)</span> <span class="c1"># Get all pixels with connectivity &gt; 2</span>

    <span class="k">for</span> <span class="n">y</span><span class="p">,</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">ypix</span><span class="p">,</span> <span class="n">xpix</span><span class="p">):</span>
        <span class="n">nv</span> <span class="o">=</span> <span class="n">imu</span><span class="o">.</span><span class="n">neighbor_vals</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>

        <span class="c1"># Skip edge cases</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">any</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">nv</span><span class="p">))</span> <span class="o">==</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">continue</span>

        <span class="c1"># Create 3x3 array with center pixel removed</span>
        <span class="n">Inv</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="n">nv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">nv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">nv</span><span class="p">[</span><span class="mi">2</span><span class="p">]],</span> <span class="p">[</span><span class="n">nv</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span>
                         <span class="n">nv</span><span class="p">[</span><span class="mi">4</span><span class="p">]],</span> <span class="p">[</span><span class="n">nv</span><span class="p">[</span><span class="mi">5</span><span class="p">],</span> <span class="n">nv</span><span class="p">[</span><span class="mi">6</span><span class="p">],</span> <span class="n">nv</span><span class="p">[</span><span class="mi">7</span><span class="p">]]],</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>

        <span class="c1"># Check the connectivity after removing the pixel, set to zero if unchanged</span>
        <span class="n">Ilabeled</span> <span class="o">=</span> <span class="n">measure</span><span class="o">.</span><span class="n">label</span><span class="p">(</span><span class="n">Inv</span><span class="p">,</span> <span class="n">background</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Ilabeled</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">Iskel</span><span class="p">[</span><span class="n">y</span><span class="p">,</span><span class="n">x</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="c1"># We simplify the network if we actually add pixels to the centers of</span>
    <span class="c1"># &quot;+&quot; cases, so let&#39;s do that.</span>
    <span class="n">kern</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">],</span> <span class="p">[</span><span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">],</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">]],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">uint8</span><span class="p">)</span>
    <span class="n">Iconv</span> <span class="o">=</span> <span class="n">cv2</span><span class="o">.</span><span class="n">filter2D</span><span class="p">(</span><span class="n">Iskel</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">kern</span><span class="p">)</span>
    <span class="n">Iskel</span><span class="p">[</span><span class="n">Iconv</span><span class="o">==</span><span class="mi">40</span><span class="p">]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="k">return</span> <span class="n">Iskel</span></div>


<div class="viewcode-block" id="pad_river_im"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.mask_to_graph.pad_river_im">[docs]</a><span class="k">def</span> <span class="nf">pad_river_im</span><span class="p">(</span><span class="n">I</span><span class="p">,</span> <span class="n">es</span><span class="p">,</span> <span class="n">pm</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Pads the edges of a binary river image by extending the ends of the river.</span>
<span class="sd">    Different than mirrored padding in that the &quot;mirror&quot; here is just a</span>
<span class="sd">    rectangle. This simplifies skeletonization and interpretation in cases</span>
<span class="sd">    where the channel is complex near the boundaries.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    I : np.array</span>
<span class="sd">        Binary image to pad; typically a river channel network.</span>
<span class="sd">    es : str</span>
<span class="sd">        A two-character string (from N, E, S, or W) that denotes which sides</span>
<span class="sd">        of the image the river intersects (upstream first) -- e.g. &#39;NS&#39;, &#39;EW&#39;,</span>
<span class="sd">        &#39;NW&#39;, etc.</span>
<span class="sd">    pm : int, optional</span>
<span class="sd">        Pad multiplier that sets the size of the padding. Multplies the blob</span>
<span class="sd">        size along the axis of the image that the blob intersect to determine</span>
<span class="sd">        the padding distance. The default is 2.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    Ip : np.array</span>
<span class="sd">        The padded image..</span>
<span class="sd">    pads : list</span>
<span class="sd">        4 entry list containing the number of pixels padded on the [n, s, e, w]</span>
<span class="sd">        edges of the image.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">Ip</span> <span class="o">=</span> <span class="n">I</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span> <span class="c1"># so original array is not modified</span>
    <span class="n">pads</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span> <span class="c1"># saves the number of pixels padded to each [n,s,e,w] edge</span>

    <span class="k">if</span> <span class="s1">&#39;n&#39;</span> <span class="ow">in</span> <span class="n">es</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>
        <span class="n">rowidcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="mi">0</span><span class="p">,:]</span><span class="o">==</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rowidcs</span><span class="p">)</span>
        <span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rowidcs</span><span class="p">)</span>
        <span class="n">pads</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">en</span><span class="o">-</span><span class="n">st</span><span class="p">)</span> <span class="o">*</span> <span class="n">pm</span>

        <span class="c1"># Make pad</span>
        <span class="n">addpad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pads</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">addpad</span><span class="p">[:,</span><span class="n">rowidcs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Add pad to image</span>
        <span class="n">Ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">addpad</span><span class="p">,</span> <span class="n">Ip</span><span class="p">))</span>

    <span class="k">if</span> <span class="s1">&#39;s&#39;</span> <span class="ow">in</span> <span class="n">es</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>

        <span class="n">rowidcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,:]</span><span class="o">==</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">rowidcs</span><span class="p">)</span>
        <span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">rowidcs</span><span class="p">)</span>
        <span class="n">pads</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">en</span><span class="o">-</span><span class="n">st</span><span class="p">)</span> <span class="o">*</span> <span class="n">pm</span>

        <span class="c1"># Make pad</span>
        <span class="n">addpad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">pads</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Ip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">addpad</span><span class="p">[:,</span><span class="n">rowidcs</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="c1"># Add pad to image</span>
        <span class="n">Ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Ip</span><span class="p">,</span> <span class="n">addpad</span><span class="p">))</span>

    <span class="k">if</span> <span class="s1">&#39;e&#39;</span> <span class="ow">in</span> <span class="n">es</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>

        <span class="n">colidcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[:,</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">colidcs</span><span class="p">)</span>
        <span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">colidcs</span><span class="p">)</span>
        <span class="n">pads</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">en</span><span class="o">-</span><span class="n">st</span><span class="p">)</span> <span class="o">*</span> <span class="n">pm</span>

        <span class="c1"># Make pad</span>
        <span class="n">addpad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pads</span><span class="p">[</span><span class="mi">2</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">addpad</span><span class="p">[</span><span class="n">colidcs</span><span class="p">,:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">Ip</span><span class="p">,</span> <span class="n">addpad</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;w&#39;</span> <span class="ow">in</span> <span class="n">es</span><span class="o">.</span><span class="n">lower</span><span class="p">():</span>

        <span class="n">colidcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ip</span><span class="p">[:,</span><span class="mi">0</span><span class="p">]</span><span class="o">==</span><span class="kc">True</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">st</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">colidcs</span><span class="p">)</span>
        <span class="n">en</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">colidcs</span><span class="p">)</span>
        <span class="n">pads</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">en</span><span class="o">-</span><span class="n">st</span><span class="p">)</span> <span class="o">*</span> <span class="n">pm</span>

        <span class="c1"># Make pad</span>
        <span class="n">addpad</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">Ip</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">pads</span><span class="p">[</span><span class="mi">3</span><span class="p">]),</span> <span class="n">dtype</span><span class="o">=</span><span class="nb">bool</span><span class="p">)</span>
        <span class="n">addpad</span><span class="p">[</span><span class="n">colidcs</span><span class="p">,:]</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="n">Ip</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">addpad</span><span class="p">,</span> <span class="n">Ip</span><span class="p">),</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">Ip</span><span class="p">,</span> <span class="n">pads</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, J. Schwenk &amp; J. Hariharan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>