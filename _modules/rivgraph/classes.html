<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rivgraph.classes &mdash; RivGraph 0.5.0 documentation</title>
      <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/sphinx_highlight.js"></script>
    <script src="../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../index.html">
            <img src="../../_static/rg_logo_full.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../background/index.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../install/index.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../maskmaking/index.html">Maskmaking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../shoreline/index.html">Shoreline creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../linksnodes/index.html">Link and Node Dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../issues/index.html">Known issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../featuredevelopment/index.html">Feature Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../gallery/index.html">RivGraph in the wild</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../apiref/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">RivGraph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../index.html" class="icon icon-home"></a></li>
          <li class="breadcrumb-item"><a href="../index.html">Module code</a></li>
      <li class="breadcrumb-item active">rivgraph.classes</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for rivgraph.classes</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">RivGraph (classes.py)</span>
<span class="sd">=====================</span>
<span class="sd">Classes for running rivgraph commands on your channel network or centerline.</span>

<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">sys</span>
<span class="kn">from</span> <span class="nn">loguru</span> <span class="kn">import</span> <span class="n">logger</span>
<span class="k">try</span><span class="p">:</span>
    <span class="kn">from</span> <span class="nn">osgeo</span> <span class="kn">import</span> <span class="n">gdal</span>
<span class="k">except</span> <span class="ne">ModuleNotFoundError</span><span class="p">:</span>
    <span class="kn">import</span> <span class="nn">gdal</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">pyproj.crs</span> <span class="kn">import</span> <span class="n">CRS</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage</span> <span class="kn">import</span> <span class="n">distance_transform_edt</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LineString</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">import</span> <span class="nn">rivgraph.io_utils</span> <span class="k">as</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">rivgraph.geo_utils</span> <span class="k">as</span> <span class="nn">gu</span>
<span class="kn">import</span> <span class="nn">rivgraph.mask_to_graph</span> <span class="k">as</span> <span class="nn">m2g</span>
<span class="kn">import</span> <span class="nn">rivgraph.ln_utils</span> <span class="k">as</span> <span class="nn">lnu</span>
<span class="kn">import</span> <span class="nn">rivgraph.mask_utils</span> <span class="k">as</span> <span class="nn">mu</span>
<span class="kn">import</span> <span class="nn">rivgraph.deltas.delta_utils</span> <span class="k">as</span> <span class="nn">du</span>
<span class="kn">import</span> <span class="nn">rivgraph.deltas.delta_directionality</span> <span class="k">as</span> <span class="nn">dd</span>
<span class="kn">import</span> <span class="nn">rivgraph.deltas.delta_metrics</span> <span class="k">as</span> <span class="nn">dm</span>
<span class="kn">import</span> <span class="nn">rivgraph.rivers.river_directionality</span> <span class="k">as</span> <span class="nn">rd</span>
<span class="kn">import</span> <span class="nn">rivgraph.rivers.river_utils</span> <span class="k">as</span> <span class="nn">ru</span>
<span class="kn">import</span> <span class="nn">rivgraph.rivers.centerline_utils</span> <span class="k">as</span> <span class="nn">cu</span>

<div class="viewcode-block" id="rivnetwork"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork">[docs]</a><span class="k">class</span> <span class="nc">rivnetwork</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Base rivnetwork class.</span>

<span class="sd">    The rivnetwork class organizes data and methods for channel networks. This</span>
<span class="sd">    is a parent class to the delta and river classes which inherit rivnetwork</span>
<span class="sd">    methods and attributes. This class thus represents the common elements of</span>
<span class="sd">    river and delta channel networks.</span>

<span class="sd">    &quot;&quot;&quot;</span>


<div class="viewcode-block" id="rivnetwork.__init__"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path_to_mask</span><span class="p">,</span> <span class="n">results_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">exit_sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Initializes a channelnetwork class.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the channel network; also defines the folder name for</span>
<span class="sd">            storing results.</span>
<span class="sd">        path_to_mask : str</span>
<span class="sd">            Points to the channel network mask file path</span>
<span class="sd">        results_folder : str, optional</span>
<span class="sd">            Specifies a directory where results should be stored</span>
<span class="sd">        exit_sides : str, optional</span>
<span class="sd">            Only required for river channel netowrks. A two-character string</span>
<span class="sd">            (from N, E, S, or W) that denotes which sides of the image the</span>
<span class="sd">            river intersects (upstream first) -- e.g. &#39;NS&#39;, &#39;EW&#39;, &#39;NW&#39;, etc.</span>
<span class="sd">        verbose : bool, optional</span>
<span class="sd">            If True, print run information and warnings to the console, default</span>
<span class="sd">            is False.</span>


<span class="sd">        Attributes</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            the name of the channel network, usually the river or delta&#39;s name</span>
<span class="sd">        verbose : bool, optional (False by default)</span>
<span class="sd">            True or False to specify if processing updates should be printed.</span>
<span class="sd">        d : osgeo.gdal.Dataset</span>
<span class="sd">            object created by gdal.Open() that provides access to geotiff</span>
<span class="sd">            metadata</span>
<span class="sd">        mask_path : str</span>
<span class="sd">            filepath to the input binary channel network mask</span>
<span class="sd">        imshape : tuple</span>
<span class="sd">            dimensions of the image (rows, cols)</span>
<span class="sd">        gt : tuple</span>
<span class="sd">            gdal-type Geotransform of the input mask geotiff</span>
<span class="sd">        wkt : str</span>
<span class="sd">            well known text representation of coordinate reference system of</span>
<span class="sd">            input mask geotiff</span>
<span class="sd">        epsg: int</span>
<span class="sd">            epsg code of the coordinate reference system of input mask geotiff</span>
<span class="sd">        unit: str</span>
<span class="sd">            units of the coordinate reference system; typically &#39;degree&#39; or</span>
<span class="sd">            &#39;meter&#39;</span>
<span class="sd">        pixarea: int or float</span>
<span class="sd">            area of each pixel, in units of &#39;unit&#39;</span>
<span class="sd">        pixlen: int or float</span>
<span class="sd">            length of each pixel, assumes sides are equal-length</span>
<span class="sd">        paths: dict</span>
<span class="sd">            dictionary of strings for managing where files should be</span>
<span class="sd">            read/written</span>
<span class="sd">        exit_sides: str</span>
<span class="sd">            two-character string denoting which sides of the image the channel</span>
<span class="sd">            network intersects (N,E,S, and/or W). Upstream side should be given</span>
<span class="sd">            first.</span>
<span class="sd">        Imask: numpy.ndarray</span>
<span class="sd">            binary mask found at mask_path loaded into a numpy array via</span>
<span class="sd">            `gdal.Open().ReadAsArray()`, dtype=np.bool</span>
<span class="sd">        links: dict</span>
<span class="sd">            Stores the links of the network and associated properties</span>
<span class="sd">        nodes: dict</span>
<span class="sd">            Stores the nodes of the network and associated properties</span>
<span class="sd">        Idist: numpy.ndarray</span>
<span class="sd">            image of the distance transform of the binary mask, dtype=np.float</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store some class attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">name</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="o">=</span> <span class="n">verbose</span>

        <span class="c1"># Prepare paths for saving</span>
        <span class="k">if</span> <span class="n">results_folder</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">prepare_paths</span><span class="p">(</span><span class="n">results_folder</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path_to_mask</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">paths</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">prepare_paths</span><span class="p">(</span>
                            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span>
                                <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">path_to_mask</span><span class="p">)),</span> <span class="n">name</span><span class="p">,</span>
                            <span class="n">path_to_mask</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;input_mask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">normpath</span><span class="p">(</span><span class="n">path_to_mask</span><span class="p">)</span>

        <span class="c1"># init logger - prints out to stdout if verbose is True</span>
        <span class="c1"># ALWAYS writes output to log file (doesn&#39;t print if verbose is False)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">init_logger</span><span class="p">()</span>

        <span class="c1"># Handle georeferencing</span>
        <span class="c1"># GA_Update required for setting dummy projection/geotransform</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;input_mask&#39;</span><span class="p">],</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GA_Update</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">imshape</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">RasterYSize</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">RasterXSize</span><span class="p">)</span>

        <span class="c1"># Create dummy georeferencing if none is supplied</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Input mask is unprojected; assigning a dummy projection.&#39;</span><span class="p">)</span>
            <span class="c1"># Creates a dummy projection in EPSG:4326 with UL coordinates (0,0)</span>
            <span class="c1"># and pixel resolution = 1.</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wkt</span> <span class="o">=</span> <span class="s1">&#39;GEOGCS[&quot;WGS 84&quot;,DATUM[&quot;WGS_1984&quot;,SPHEROID[&quot;WGS 84&quot;,6378137,298.257223563,AUTHORITY[&quot;EPSG&quot;,&quot;7030&quot;]],AUTHORITY[&quot;EPSG&quot;,&quot;6326&quot;]],PRIMEM[&quot;Greenwich&quot;,0,AUTHORITY[&quot;EPSG&quot;,&quot;8901&quot;]],UNIT[&quot;degree&quot;,0.01745329251994328,AUTHORITY[&quot;EPSG&quot;,&quot;9122&quot;]],AUTHORITY[&quot;EPSG&quot;,&quot;4326&quot;]]&#39;</span> <span class="c1"># 4326</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">SetProjection</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">wkt</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">SetGeoTransform</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshape</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">wkt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gt</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">GetGeoTransform</span><span class="p">()</span>

        <span class="c1"># Store crs as pyproj CRS object for interacting with geopandas</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">CRS</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">GetProjection</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">unit</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">get_unit</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">pixarea</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">[</span><span class="mi">5</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">pixlen</span> <span class="o">=</span> <span class="nb">abs</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

        <span class="c1"># Save exit sides</span>
        <span class="k">if</span> <span class="n">exit_sides</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">exit_sides</span> <span class="o">=</span> <span class="n">exit_sides</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

        <span class="c1"># Load mask into memory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">Imask</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span></div>


<div class="viewcode-block" id="rivnetwork.init_logger"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.init_logger">[docs]</a>    <span class="k">def</span> <span class="nf">init_logger</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Function to initialize the logger.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">verbose</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">handlers</span><span class="o">=</span><span class="p">[</span>
                    <span class="nb">dict</span><span class="p">(</span><span class="n">sink</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">],</span>
                         <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;[{time:YYYY-MM-DD at HH:mm:ss}] | </span><span class="si">{message}</span><span class="s2">&quot;</span><span class="p">),</span>
                    <span class="nb">dict</span><span class="p">(</span><span class="n">sink</span><span class="o">=</span><span class="n">sys</span><span class="o">.</span><span class="n">stdout</span><span class="p">,</span>
                         <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;</span><span class="si">{message}</span><span class="s2">&quot;</span><span class="p">)</span>
                <span class="p">],</span>
                <span class="n">activation</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)],</span>
            <span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">configure</span><span class="p">(</span>
                <span class="n">handlers</span><span class="o">=</span><span class="p">[</span>
                    <span class="nb">dict</span><span class="p">(</span><span class="n">sink</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;log&#39;</span><span class="p">],</span>
                         <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;[{time:YYYY-MM-DD at HH:mm:ss}] | </span><span class="si">{message}</span><span class="s2">&quot;</span><span class="p">),</span>
                <span class="p">],</span>
                <span class="n">activation</span><span class="o">=</span><span class="p">[(</span><span class="s2">&quot;&quot;</span><span class="p">,</span> <span class="kc">True</span><span class="p">)],</span>
            <span class="p">)</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">10</span> <span class="o">+</span> <span class="s2">&quot; New Run &quot;</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span><span class="o">*</span><span class="mi">10</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.compute_network"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.compute_network">[docs]</a>    <span class="k">def</span> <span class="nf">compute_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the links and nodes of the channel network mask.</span>
<span class="sd">        First skeletonizes the mask if not already done, then resolves the</span>
<span class="sd">        skeleton&#39;s graph.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Iskel&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Resolving links and nodes...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">m2g</span><span class="o">.</span><span class="n">skel_to_graph</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Iskel</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;links and nodes have been resolved.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.compute_distance_transform"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.compute_distance_transform">[docs]</a>    <span class="k">def</span> <span class="nf">compute_distance_transform</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the distance transform of the channel network mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Load the distance transform if it already exists</span>
        <span class="k">if</span> <span class="s1">&#39;Idist&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> \
            <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Idist&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Idist</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Idist&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing distance transform...&#39;</span><span class="p">,</span> <span class="n">end</span><span class="o">=</span><span class="s1">&#39;&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Idist</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;distance transform done.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.compute_link_width_and_length"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.compute_link_width_and_length">[docs]</a>    <span class="k">def</span> <span class="nf">compute_link_width_and_length</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes widths and lengths of each link in the links dictionary and</span>
<span class="sd">        appends them as dictionary attributes.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_network</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Idist&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_distance_transform</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing link widths and lengths...&#39;</span><span class="p">)</span>

        <span class="c1"># Widths and lengths are appended to links dict</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_widths_and_lengths</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Idist</span><span class="p">,</span>
                                                 <span class="n">pixlen</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">pixlen</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;link widths and lengths computed.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.compute_junction_angles"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.compute_junction_angles">[docs]</a>    <span class="k">def</span> <span class="nf">compute_junction_angles</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the angle at nodes where only three links are connected.</span>
<span class="sd">        Directions must be assigned before angles can be computed. Also defines</span>
<span class="sd">        each 3-link node as &#39;confluence&#39; or &#39;bifurcation&#39; and appends this</span>
<span class="sd">        designation to the nodes dictionary.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : str</span>
<span class="sd">            [None], &#39;exp&#39; (exponential), or &#39;lin&#39; (linear) to determine the</span>
<span class="sd">            decay of the weights the contributions of pixels as we move away</span>
<span class="sd">            from the junction node.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;certain&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Junction angles cannot be computed before link directions are set.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">junction_angles</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span>
                                             <span class="bp">self</span><span class="o">.</span><span class="n">imshape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixlen</span><span class="p">,</span>
                                             <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.get_islands"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.get_islands">[docs]</a>    <span class="k">def</span> <span class="nf">get_islands</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">props</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;area&#39;</span><span class="p">,</span> <span class="s1">&#39;maxwidth&#39;</span><span class="p">,</span> <span class="s1">&#39;major_axis_length&#39;</span><span class="p">,</span>
                                 <span class="s1">&#39;minor_axis_length&#39;</span><span class="p">,</span> <span class="s1">&#39;surrounding_links&#39;</span><span class="p">],</span>
                          <span class="n">connectivity</span><span class="o">=</span><span class="mi">2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds all the islands in the binary mask and computes their morphological</span>
<span class="sd">        properties. Can be used to help &quot;clean&quot; masks of small islands. Must</span>
<span class="sd">        run compute_network() first.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        props : list, optional</span>
<span class="sd">            Properties to compute for each island. Properties can be any of those</span>
<span class="sd">            provided by rivgraph.im_utils.regionprops.</span>
<span class="sd">            The default is [&#39;area&#39;, &#39;maxwidth&#39;, &#39;major_axis_length&#39;, &#39;minor_axis_length&#39;].</span>
<span class="sd">        connectivity : int, optional</span>
<span class="sd">            If 1, 4-connectivity will be used to determine connected blobs. If</span>
<span class="sd">            2, 8-connectivity will be used. The default is 2.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        islands : geopandas GeoDataFrame</span>
<span class="sd">             Contains the polygons of each island with the requested property</span>
<span class="sd">             attributes as columns. An additional &#39;remove&#39; attribute is</span>
<span class="sd">             initialized to make thresholding easier.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">do_surr</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="s1">&#39;surrounding_links&#39;</span> <span class="ow">in</span> <span class="n">props</span><span class="p">:</span>
            <span class="n">props</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;surrounding_links&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                <span class="n">do_surr</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Cannot compute surrounding island links without first computing the network. Skipping.&#39;</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Getting island properties...&#39;</span><span class="p">)</span>

        <span class="n">islands</span><span class="p">,</span> <span class="n">Iislands</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">get_island_properties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixlen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixarea</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="n">props</span><span class="p">,</span> <span class="n">connectivity</span><span class="o">=</span><span class="n">connectivity</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;got island properties.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">do_surr</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="s1">&#39;wid_adj&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_link_width_and_length</span><span class="p">()</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing surrounding links for each island...&#39;</span><span class="p">)</span>

            <span class="n">islands</span> <span class="o">=</span> <span class="n">mu</span><span class="o">.</span><span class="n">surrounding_link_properties</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">,</span> <span class="n">islands</span><span class="p">,</span> <span class="n">Iislands</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixlen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixarea</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;surrounding links computed.&#39;</span><span class="p">)</span>

        <span class="c1"># Add a column to be used for thresholding</span>
        <span class="n">islands</span><span class="p">[</span><span class="s1">&#39;remove&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="kc">False</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">islands</span><span class="p">))]</span>

        <span class="k">return</span> <span class="n">islands</span><span class="p">,</span> <span class="n">Iislands</span></div>


<div class="viewcode-block" id="rivnetwork.plot"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.plot">[docs]</a>    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">kwargs</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates matplotlib plots of the network.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        *kwargs : str</span>
<span class="sd">            If [None], both of the following plots will be generated:</span>
<span class="sd">            &#39;network&#39;: links and nodes are plotted, labeled with their ids</span>
<span class="sd">            &#39;directions&#39;: links are plotted with their directionality indicated</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1">## TODO: add error handling for wrong plotting commands</span>

        <span class="n">plt_directions</span><span class="p">,</span> <span class="n">plt_network</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">plt_directions</span> <span class="o">=</span> <span class="kc">True</span>
            <span class="n">plt_network</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s1">&#39;network&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">plt_network</span> <span class="o">=</span> <span class="kc">True</span>
        <span class="k">if</span> <span class="s1">&#39;directions&#39;</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="n">plt_directions</span> <span class="o">=</span> <span class="kc">True</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No path is available to load the network.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">plt_directions</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="k">if</span> <span class="s1">&#39;certain&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Must assign link directions before plotting link directions.&#39;</span><span class="p">)</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">d</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">plot_dirlinks</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshape</span><span class="p">)</span>
                <span class="k">return</span> <span class="n">d</span>

        <span class="k">if</span> <span class="n">plt_network</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">f</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">plot_network</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="n">axis</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">f</span></div>


<div class="viewcode-block" id="rivnetwork.save_network"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.save_network">[docs]</a>    <span class="k">def</span> <span class="nf">save_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the link and nodes dictionaries to a .pkl file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            path--including extension--to network .pkl file. If [None], file</span>
<span class="sd">            written to path found in paths[&#39;network_pickle&#39;]</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">path</span><span class="o">==</span><span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;paths&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No path is available to load the network.&#39;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;network_pickle&#39;</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">io</span><span class="o">.</span><span class="n">pickle_links_and_nodes</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">path</span><span class="p">)</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Links and nodes saved to pickle file: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;network_pickle&#39;</span><span class="p">]))</span>
            <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Network has not been computed yet. Use the compute_network() method first.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.load_network"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.load_network">[docs]</a>    <span class="k">def</span> <span class="nf">load_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Loads the link and nodes dictionaries from a .pkl file.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path : str</span>
<span class="sd">            path--including extension--to network .pkl file. If [None], file</span>
<span class="sd">            is loaded from path found in paths[&#39;network_pickle&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">path</span><span class="o">==</span><span class="kc">None</span> <span class="ow">and</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;paths&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No path is available to load the network.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">path</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;network_pickle&#39;</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">path</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;No file was found at provided path: </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">unpickle_links_and_nodes</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.adjacency_matrix"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.adjacency_matrix">[docs]</a>    <span class="k">def</span> <span class="nf">adjacency_matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">normalized</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns the adjacency matrix for a graph defined by links and nodes</span>
<span class="sd">        dictionaries.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        weight : str, optional</span>
<span class="sd">            [None] or the attribute in the links dictionary to use for weighting links. Typically &#39;wid_adj&#39; or &#39;len&#39;.</span>
<span class="sd">        normalized : bool, optional</span>
<span class="sd">            If True, each row in the adjacency matrix will sum to one. [False] by default.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        A : numpy.ndarray</span>
<span class="sd">            an NxN matrix representing the connectivity of the graph, where N</span>
<span class="sd">            is the number of nodes in the network. See adjacency matrix for more details.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Create (weighted) adjacency matrix networkx object</span>
        <span class="n">G</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">graphiphy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">weight</span><span class="o">=</span><span class="n">weight</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">normalized</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">normalize_adj_matrix</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">A</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">to_numpy_array</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">A</span></div>


<div class="viewcode-block" id="rivnetwork.to_geovectors"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.to_geovectors">[docs]</a>    <span class="k">def</span> <span class="nf">to_geovectors</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">export</span><span class="o">=</span><span class="s1">&#39;network&#39;</span><span class="p">,</span> <span class="n">ftype</span><span class="o">=</span><span class="s1">&#39;json&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the links and nodes of the network to geovectors.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        export : str</span>
<span class="sd">            Determines which features to export. Choose from:</span>

<span class="sd">            - all (exports all available vector data)</span>

<span class="sd">            - network (links and nodes)</span>

<span class="sd">            - links</span>

<span class="sd">            - nodes</span>

<span class="sd">            - centerline (river classes only)</span>

<span class="sd">            - mesh (centerline mesh, river classes only)</span>

<span class="sd">            - centerline_smooth (river classes only)</span>

<span class="sd">        ftype : str</span>
<span class="sd">            Sets the output file format. Choose from:</span>

<span class="sd">            - json (GeoJSON)</span>

<span class="sd">            - shp  (ESRI Shapefile)</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Get extension for requested output type</span>
        <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;json&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;json&#39;</span>
        <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;shp&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;shp&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s1">&#39;Only json and shp output types are supported.&#39;</span><span class="p">)</span>

        <span class="c1"># Prepare list of desired exports</span>
        <span class="k">if</span> <span class="n">export</span> <span class="o">==</span> <span class="s1">&#39;all&#39;</span><span class="p">:</span>
            <span class="n">to_export</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">,</span> <span class="s1">&#39;nodes&#39;</span><span class="p">,</span> <span class="s1">&#39;mesh&#39;</span><span class="p">,</span> <span class="s1">&#39;centerline&#39;</span><span class="p">,</span> <span class="s1">&#39;centerline_smooth&#39;</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">export</span> <span class="o">==</span> <span class="s1">&#39;network&#39;</span><span class="p">:</span>
            <span class="n">to_export</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">,</span> <span class="s1">&#39;nodes&#39;</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">to_export</span> <span class="o">=</span> <span class="p">[</span><span class="n">export</span><span class="p">]</span>

        <span class="c1"># Ensure that each requested vector dataset has been computed, then export it</span>
        <span class="k">for</span> <span class="n">te</span> <span class="ow">in</span> <span class="n">to_export</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">te</span> <span class="o">==</span> <span class="s1">&#39;links&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;basepath&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_links.&#39;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                    <span class="n">io</span><span class="o">.</span><span class="n">links_to_geofile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;links&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Links have not been computed and thus cannot be exported.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">te</span> <span class="o">==</span> <span class="s1">&#39;nodes&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;nodes&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;basepath&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_nodes.&#39;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                    <span class="n">io</span><span class="o">.</span><span class="n">nodes_to_geofile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshape</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;nodes&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Nodes have not been computed and thus cannot be exported.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">te</span> <span class="o">==</span> <span class="s1">&#39;mesh&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;meshlines&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">river</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;meshlines&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;basepath&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_meshlines.&#39;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;meshpolys&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;basepath&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_meshpolys.&#39;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                    <span class="n">io</span><span class="o">.</span><span class="n">shapely_list_to_geovectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshlines</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;meshlines&#39;</span><span class="p">])</span>
                    <span class="n">io</span><span class="o">.</span><span class="n">shapely_list_to_geovectors</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">meshpolys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;meshpolys&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Mesh has not been computed and thus cannot be exported.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">te</span> <span class="o">==</span> <span class="s1">&#39;centerline&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;centerline&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">river</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;centerline&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;basepath&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_centerline.&#39;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                    <span class="n">io</span><span class="o">.</span><span class="n">centerline_to_geovector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centerline</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;centerline&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Centerlines has not been computed and thus cannot be exported.&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">te</span> <span class="o">==</span> <span class="s1">&#39;centerline_smooth&#39;</span><span class="p">:</span>
                <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;centerline_smooth&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">True</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="ow">is</span> <span class="n">river</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;centerline_smooth&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;basepath&#39;</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;_centerline_smooth.&#39;</span> <span class="o">+</span> <span class="n">ext</span><span class="p">)</span>
                    <span class="n">io</span><span class="o">.</span><span class="n">centerline_to_geovector</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centerline_smooth</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;centerline_smooth&#39;</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Smoothed centerline has not been computed and thus cannot be exported.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="rivnetwork.to_geotiff"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.rivnetwork.to_geotiff">[docs]</a>    <span class="k">def</span> <span class="nf">to_geotiff</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">export</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes geotiffs to disk.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        export : str</span>
<span class="sd">            Select a raster to write to geotiff. Choose from:</span>
<span class="sd">                &#39;directions&#39; - network burned into a raster with link directions from 0 (upstream) to 1 (downstream))</span>
<span class="sd">                &#39;skeleton&#39;  - skeletonized mask</span>
<span class="sd">                &#39;distance&#39; - distance-transformed mask</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">valid_exports</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;directions&#39;</span><span class="p">,</span> <span class="s1">&#39;distance&#39;</span><span class="p">,</span> <span class="s1">&#39;skeleton&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">export</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">valid_exports</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Cannot write </span><span class="si">{}</span><span class="s1">. Choose from </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">export</span><span class="p">,</span> <span class="n">valid_exports</span><span class="p">))</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="n">export</span> <span class="o">==</span> <span class="s1">&#39;directions&#39;</span><span class="p">:</span>
            <span class="n">outpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;linkdirs&#39;</span><span class="p">]</span>
            <span class="n">io</span><span class="o">.</span><span class="n">write_linkdirs_geotiff</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="p">,</span> <span class="n">outpath</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">export</span> <span class="o">==</span> <span class="s1">&#39;distance&#39;</span><span class="p">:</span>
                <span class="n">raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Idist</span>
                <span class="n">outpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Idist&#39;</span><span class="p">]</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GDT_Float32</span>
                <span class="n">color_table</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">options</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">nbands</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="k">elif</span> <span class="n">export</span> <span class="o">==</span> <span class="s1">&#39;skeleton&#39;</span><span class="p">:</span>
                <span class="n">raster</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iskel</span>
                <span class="n">outpath</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Iskel&#39;</span><span class="p">]</span>
                <span class="n">dtype</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">GDT_Byte</span>
                <span class="n">color_table</span> <span class="o">=</span> <span class="n">io</span><span class="o">.</span><span class="n">colortable</span><span class="p">(</span><span class="s1">&#39;skel&#39;</span><span class="p">)</span>
                <span class="n">options</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;COMPRESS=LZW&#39;</span><span class="p">]</span>
                <span class="n">nbands</span> <span class="o">=</span> <span class="mi">1</span>

            <span class="n">io</span><span class="o">.</span><span class="n">write_geotiff</span><span class="p">(</span><span class="n">raster</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">wkt</span><span class="p">,</span> <span class="n">outpath</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="n">dtype</span><span class="p">,</span> <span class="n">options</span><span class="o">=</span><span class="n">options</span><span class="p">,</span> <span class="n">color_table</span><span class="o">=</span><span class="n">color_table</span><span class="p">,</span> <span class="n">nbands</span><span class="o">=</span><span class="n">nbands</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Geotiff written to </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">outpath</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="delta"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.delta">[docs]</a><span class="k">class</span> <span class="nc">delta</span><span class="p">(</span><span class="n">rivnetwork</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to manage and organize data and methods for analyzing a delta channel network.</span>
<span class="sd">    This class inherits all the attributes and methods of the rivnetwork class,</span>
<span class="sd">    but also includes delta-specific attributes and methods.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    Iskel : np.ndarray</span>
<span class="sd">        image of the skeletonized binary mask</span>
<span class="sd">    topo_metrics : dict</span>
<span class="sd">        Contains a number of connectivity and network metrics.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="delta.__init__"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.delta.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path_to_mask</span><span class="p">,</span> <span class="n">results_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        name : str</span>
<span class="sd">            The name of the delta channel network; also defines the folder name for storing results.</span>
<span class="sd">        path_to_mask : str</span>
<span class="sd">            Points to the channel network mask file path</span>
<span class="sd">        results_folder : str, optional</span>
<span class="sd">            Specifies a directory where results should be stored</span>
<span class="sd">        verbose : str, optional</span>
<span class="sd">            RivGraph will output processing progress if &#39;True&#39;. Default is &#39;False&#39;.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">rivnetwork</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path_to_mask</span><span class="p">,</span> <span class="n">results_folder</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="delta.skeletonize"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.delta.skeletonize">[docs]</a>    <span class="k">def</span> <span class="nf">skeletonize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Skeletonizes the delta binary mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Imask&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Mask array was not provided or was unreadable.&#39;</span><span class="p">)</span>

        <span class="c1"># Load the skeleton if it already exists</span>
        <span class="k">if</span> <span class="s1">&#39;Iskel&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Iskel&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Iskel</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Iskel&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Skeletonizing mask...&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Iskel</span> <span class="o">=</span> <span class="n">m2g</span><span class="o">.</span><span class="n">skeletonize_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;done skeletonization.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="delta.prune_network"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.delta.prune_network">[docs]</a>    <span class="k">def</span> <span class="nf">prune_network</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path_shoreline</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path_inletnodes</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                      <span class="n">prune_less</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prunes the delta by removing spurs and links beyond the provided shoreline.</span>
<span class="sd">        Paths may be provided to shoreline and inlet nodes shapefiles, otherwise</span>
<span class="sd">        their location is specified by paths dictionary.</span>


<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        path_shoreline : str, optional</span>
<span class="sd">            Path to shoreline shapefile/geosjon. The default is None but will</span>
<span class="sd">            check for the file at `paths[&#39;shoreline&#39;]`.</span>
<span class="sd">        path_inletnodes : str, optional</span>
<span class="sd">            Path to inlet nodes shapefile/geojson. The default is None but will</span>
<span class="sd">            check for the file at `paths[&#39;inlet_nodes&#39;]`.</span>
<span class="sd">        prune_less : bool, optional</span>
<span class="sd">            Boolean to optionally prune the network less. The first spur</span>
<span class="sd">            removal can create problems, especially for very small/simple</span>
<span class="sd">            networks. Default behavior is encouraged, but in the event a bug</span>
<span class="sd">            is encountered, toggling this parameter to True may fix the issue.</span>
<span class="sd">            Default is False (more pruning).</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :</span>
<span class="sd">            None, but saves pruned links and nodes dictionaries to class object.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">path_shoreline</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">path_shoreline</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;shoreline&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Could not find shoreline shapefile which should be at </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;shoreline&#39;</span><span class="p">]))</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">path_inletnodes</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">path_inletnodes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;inlet_nodes&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Could not inlet_nodes shapefile which should be at </span><span class="si">{}</span><span class="s1">.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;inlet_nodes&#39;</span><span class="p">]))</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">du</span><span class="o">.</span><span class="n">prune_delta</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="n">path_shoreline</span><span class="p">,</span> <span class="n">path_inletnodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="p">,</span> <span class="n">prune_less</span><span class="p">)</span></div>


<div class="viewcode-block" id="delta.assign_flow_directions"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.delta.assign_flow_directions">[docs]</a>    <span class="k">def</span> <span class="nf">assign_flow_directions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes flow directions for each link in the delta channel network.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Network has not yet been computed.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;inlets&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Cannot assign flow direcitons until prune_network has been run.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;len&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_link_width_and_length</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Idist&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_distance_transform</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">dd</span><span class="o">.</span><span class="n">set_link_directions</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">imshape</span><span class="p">,</span> <span class="n">manual_set_csv</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;fixlinks_csv&#39;</span><span class="p">])</span></div>


<div class="viewcode-block" id="delta.compute_topologic_metrics"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.delta.compute_topologic_metrics">[docs]</a>    <span class="k">def</span> <span class="nf">compute_topologic_metrics</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes a suite of connectivity and network metrics for a delta channel network.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Network has not yet been computed.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="s1">&#39;certain&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Link directionality has not been computed.&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">topo_metrics</span> <span class="o">=</span> <span class="n">dm</span><span class="o">.</span><span class="n">compute_delta_metrics</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="river"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.river">[docs]</a><span class="k">class</span> <span class="nc">river</span><span class="p">(</span><span class="n">rivnetwork</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A class to manage and organize data and methods for analyzing a braided river channel network.</span>
<span class="sd">    This class inherits all the attributes and methods of the rivnetwork class, but also includes delta-specific attributes and methods.</span>


<span class="sd">    Attributes</span>
<span class="sd">    ----------</span>
<span class="sd">    Iskel : np.ndarray</span>
<span class="sd">        Image of the skeletonized binary mask</span>
<span class="sd">    topo_metrics : dict</span>
<span class="sd">        Contains a number of connectivity and network metrics.</span>
<span class="sd">    centerline : tuple of two numpy.ndarrays</span>
<span class="sd">        Centerline of the holes-filled river channel network mask. First element in tuple are x-coordinates; second are y-coordinates.</span>
<span class="sd">    centerline_smooth : shapely.geometry.LineString</span>
<span class="sd">        A smooth version of centerline</span>
<span class="sd">    max_valley_width_pixels : np.int</span>
<span class="sd">        The maximum valley width in pixels, defined by widths along the centerline</span>
<span class="sd">    width_chans : float</span>
<span class="sd">        Average channel width</span>
<span class="sd">    width_extent: float</span>
<span class="sd">        Average width of the holes-filled channel mask</span>
<span class="sd">    meshlines : list of shapely.geometry.LineString</span>
<span class="sd">        The lines of the mesh that are perpendicular to the local river direction</span>
<span class="sd">    meshpolys : list of shapely.geometry.Polygon</span>
<span class="sd">        Polygons comprising the along-channel mesh</span>

<span class="sd">    Methods</span>
<span class="sd">    -------</span>
<span class="sd">    skeletonize()</span>
<span class="sd">        Skeletonizes the river binary mask; uses a different method than for deltas.</span>
<span class="sd">    prune_network()</span>
<span class="sd">        Prunes the river channel network by removing spurs.</span>
<span class="sd">    compute_centerline()</span>
<span class="sd">        Computes the centerline of the holes-filled river channel network mask.</span>
<span class="sd">    compute_mesh(grid_spacing=None, smoothing=0.1, bufferdist=None)</span>
<span class="sd">        Computes a mesh that follows the channel centerline; grid_spacing sets the length of each grid cell; bufferdist sets the width of each grid cell.</span>
<span class="sd">    assign_flow_direcions()</span>
<span class="sd">        Computes flow directions for each link in the delta channel network.</span>
<span class="sd">    set_flow_dirs_manually()</span>
<span class="sd">        Reads a user-created .csv file found at `paths[&#39;fixlinks_csv&#39;]` to set flow directions of specified links.</span>

<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="river.__init__"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.river.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path_to_mask</span><span class="p">,</span> <span class="n">results_folder</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="n">exit_sides</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">exit_sides</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">Warning</span><span class="p">(</span><span class="s1">&#39;Must provide exit_sides for river class.&#39;</span><span class="p">)</span>

        <span class="n">rivnetwork</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">,</span> <span class="n">path_to_mask</span><span class="p">,</span> <span class="n">results_folder</span><span class="p">,</span> <span class="n">exit_sides</span><span class="p">,</span> <span class="n">verbose</span><span class="o">=</span><span class="n">verbose</span><span class="p">)</span></div>


<div class="viewcode-block" id="river.skeletonize"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.river.skeletonize">[docs]</a>    <span class="k">def</span> <span class="nf">skeletonize</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Skeletonizes the river binary mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Imask&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Mask array was not provided or was unreadable.&#39;</span><span class="p">)</span>

        <span class="c1"># Load the skeleton if it already exists</span>
        <span class="k">if</span> <span class="s1">&#39;Iskel&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="ow">and</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Iskel&#39;</span><span class="p">])</span> <span class="ow">is</span> <span class="kc">True</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">Iskel</span> <span class="o">=</span> <span class="n">gdal</span><span class="o">.</span><span class="n">Open</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;Iskel&#39;</span><span class="p">])</span><span class="o">.</span><span class="n">ReadAsArray</span><span class="p">()</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Skeletonizing mask...&#39;</span><span class="p">)</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">Iskel</span> <span class="o">=</span> <span class="n">m2g</span><span class="o">.</span><span class="n">skeletonize_river_mask</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_sides</span><span class="p">)</span>

            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;skeletonization is done.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="river.prune_network"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.river.prune_network">[docs]</a>    <span class="k">def</span> <span class="nf">prune_network</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Prunes the computed river network.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Could not prune river. Check that network has been computed.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Iskel&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">skeletonize</span><span class="p">()</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">ru</span><span class="o">.</span><span class="n">prune_river</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_sides</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Iskel</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gdobj</span><span class="p">)</span></div>


<div class="viewcode-block" id="river.compute_centerline"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.river.compute_centerline">[docs]</a>    <span class="k">def</span> <span class="nf">compute_centerline</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the centerline of the holes-filled river binary image.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing centerline...&#39;</span><span class="p">)</span>

        <span class="n">centerline_pix</span><span class="p">,</span> <span class="n">valley_centerline_widths</span> <span class="o">=</span> <span class="n">ru</span><span class="o">.</span><span class="n">mask_to_centerline</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_sides</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">max_valley_width_pixels</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">valley_centerline_widths</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">centerline</span> <span class="o">=</span> <span class="n">gu</span><span class="o">.</span><span class="n">xy_to_coords</span><span class="p">(</span><span class="n">centerline_pix</span><span class="p">[:,</span><span class="mi">0</span><span class="p">],</span> <span class="n">centerline_pix</span><span class="p">[:,</span><span class="mi">1</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;centerline computation is done.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="river.compute_mesh"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.river.compute_mesh">[docs]</a>    <span class="k">def</span> <span class="nf">compute_mesh</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">buf_halfwidth</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Generates an along-centerline mesh that indicates a valley-direction</span>
<span class="sd">        of sorts. The mesh is useful for computing spatial statistics as a function</span>
<span class="sd">        of downstream distance. The resulting mesh captures the low-frequency</span>
<span class="sd">        characteristic of the river corridor.</span>

<span class="sd">        This tool is tricky to fully automate, and the user may need to play</span>
<span class="sd">        with the smoothing and bufferdist parameters if errors are thrown or</span>
<span class="sd">        the result is not satisfying.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        grid_spacing : float</span>
<span class="sd">            Defines the distance between perpendicular-to-centerline transects.</span>
<span class="sd">            Units are defined by input mask CRS.</span>
<span class="sd">        smoothing : float</span>
<span class="sd">            Defines the smoothing window of the left- and right-valleylines as a fraction</span>
<span class="sd">            of the total centerline length. Range is [0, 1].</span>
<span class="sd">        buf_halfwidth : float</span>
<span class="sd">            Defines the offset distance of the left- and right-valleylines from</span>
<span class="sd">            from the centerline. Units correspond to those of the CRS of the</span>
<span class="sd">            input mask.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Need a centerline</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;centerline&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_centerline</span><span class="p">()</span>

        <span class="c1"># Need average channel width for parameterizing mesh generation</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;avg_chan_width&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;links&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_network</span><span class="p">()</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="s1">&#39;wid_adj&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">compute_link_width_and_length</span><span class="p">()</span>

            <span class="c1"># self.avg_chan_width = np.mean(self.links[&#39;wid_a1dj&#39;])</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">avg_chan_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixarea</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">[</span><span class="s1">&#39;len_adj&#39;</span><span class="p">])</span>

        <span class="c1"># If not specified, grid spacing is set to one channel width</span>
        <span class="k">if</span> <span class="n">grid_spacing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">grid_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_chan_width</span>

        <span class="c1"># If buffer halfwidth is not specified, it is set to 10% larger than the maximum valley width</span>
        <span class="k">if</span> <span class="n">buf_halfwidth</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># Compute the maximum valley width in pixels</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;max_valley_width_pixels&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing maximum valley width...&#39;</span><span class="p">)</span>

                <span class="bp">self</span><span class="o">.</span><span class="n">max_valley_width_pixels</span> <span class="o">=</span> <span class="n">ru</span><span class="o">.</span><span class="n">max_valley_width</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">)</span>

                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;valley width computation is done.&#39;</span><span class="p">)</span>

            <span class="c1"># Multiply by pixlen to keep units consistent</span>
            <span class="n">buf_halfwidth</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">max_valley_width_pixels</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixlen</span> <span class="o">*</span> <span class="mf">1.1</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Generating mesh...&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">meshlines</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshpolys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">centerline_smooth</span> <span class="o">=</span> <span class="n">ru</span><span class="o">.</span><span class="n">valleyline_mesh</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">centerline</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">avg_chan_width</span><span class="p">,</span> <span class="n">buf_halfwidth</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span> <span class="n">smoothing</span><span class="o">=</span><span class="n">smoothing</span><span class="p">)</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;mesh generation is done.&#39;</span><span class="p">)</span></div>


<div class="viewcode-block" id="river.assign_flow_directions"><a class="viewcode-back" href="../../apiref/rivgraph.html#rivgraph.classes.river.assign_flow_directions">[docs]</a>    <span class="k">def</span> <span class="nf">assign_flow_directions</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Automatically sets flow directions for each link in a braided river</span>
<span class="sd">        channel network.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;inlets&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="s1">&#39;Cannot assign flow directions until prune_network() has been run.&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;centerline&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_centerline</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;meshpolys&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_mesh</span><span class="p">()</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;Idist&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">compute_distance_transform</span><span class="p">()</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Setting link directionality...&#39;</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span> <span class="o">=</span> <span class="n">rd</span><span class="o">.</span><span class="n">set_directionality</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">links</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Imask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">exit_sides</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">gt</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshlines</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">meshpolys</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">Idist</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">pixlen</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">paths</span><span class="p">[</span><span class="s1">&#39;fixlinks_csv&#39;</span><span class="p">])</span>

        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;link directionality has been set.&#39;</span><span class="p">)</span></div></div>


<span class="k">class</span> <span class="nc">centerline</span><span class="p">():</span>

    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">attribs</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        attribs is a dictionary with attributes; can be single values like</span>
<span class="sd">        average channel width or one value per coordinate like local width.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># Store original coordinates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xo</span> <span class="o">=</span> <span class="n">x</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yo</span> <span class="o">=</span> <span class="n">y</span>

        <span class="c1"># Store crs info if provided</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="o">=</span> <span class="n">crs</span>

        <span class="c1"># Store attributes</span>
        <span class="k">if</span> <span class="n">attribs</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">a</span> <span class="ow">in</span> <span class="n">attribs</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>

                <span class="k">try</span><span class="p">:</span>
                    <span class="n">alen</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">attribs</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                <span class="k">except</span> <span class="ne">Exception</span><span class="p">:</span>
                    <span class="n">alen</span> <span class="o">=</span> <span class="mi">1</span>

                <span class="k">if</span> <span class="n">alen</span> <span class="o">==</span> <span class="mi">1</span> <span class="ow">or</span> <span class="n">alen</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">x</span><span class="p">):</span>
                    <span class="nb">setattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">a</span><span class="p">,</span> <span class="n">attribs</span><span class="p">[</span><span class="n">a</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Attribute </span><span class="si">{}</span><span class="s1"> does not have the proper length and is not being stored.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">a</span><span class="p">))</span>

    <span class="k">def</span> <span class="nf">__get_x_and_y</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xrs&#39;</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xrs</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yrs</span>
            <span class="n">vers</span> <span class="o">=</span> <span class="s1">&#39;resampled&#39;</span>
        <span class="k">elif</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;xs&#39;</span><span class="p">):</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xs</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ys</span>
            <span class="n">vers</span> <span class="o">=</span> <span class="s1">&#39;smooth&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">xo</span>
            <span class="n">y</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">yo</span>
            <span class="n">vers</span> <span class="o">=</span> <span class="s1">&#39;original&#39;</span>

        <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">vers</span>


    <span class="k">def</span> <span class="nf">smooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">n</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">k</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Smooths the x and y coordinates of the centerline using a k-th order</span>
<span class="sd">        Savitzky-Golay filter.</span>

<span class="sd">        window refers to the number of points to use in the moving window;</span>
<span class="sd">        must be odd n is the number of times to perform the smoothing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_cl&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_cl</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Must provide a smoothing window.&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="c1"># Ensure window is integer and odd</span>
        <span class="n">window</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">window</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">window</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">window</span> <span class="o">=</span> <span class="n">window</span> <span class="o">+</span> <span class="mi">1</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="n">k</span><span class="p">,</span>
                                       <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

        <span class="c1"># Could make this recursive but if a non-default x,y are passed in, it would not function as expected</span>
        <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">n</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">xs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">xs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                               <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">ys</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ys</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                               <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">resample</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If no arguments are provided for x and y, will resample the smoothed</span>
<span class="sd">        coordinates if available, else will resample the original coordinates.</span>

<span class="sd">        N is the number of points that the resulting centerline</span>
<span class="sd">        should contain.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">xy</span><span class="p">,</span> <span class="n">spline</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">evenly_space_line</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">npts</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">xrs</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">yrs</span> <span class="o">=</span> <span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">s</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">sss</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">s_ds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">sss</span>

    <span class="k">def</span> <span class="nf">ds</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">_</span><span class="p">,</span> <span class="n">dss</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">s_ds</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">dss</span>

    <span class="k">def</span> <span class="nf">C</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Important: curvatures are negativized to match the zs approach</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">Cs</span><span class="p">,</span> <span class="n">_</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">curvars</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="n">Cs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Cs</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span> <span class="o">-</span><span class="n">Cs</span>

    <span class="k">def</span> <span class="nf">Csmooth</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_C&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Must provide a smoothing window.&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">Cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">()</span>
        <span class="n">Cs</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">Cs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                  <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
<span class="c1">#            Cs = signal.medfilt(Cs,kernel_size=5)</span>
        <span class="k">return</span> <span class="n">Cs</span>

    <span class="k">def</span> <span class="nf">infs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Finds inflection points.</span>

<span class="sd">        N is the number of expected inflection points. It can be estimated</span>
<span class="sd">        from N ~= centerline length / 10W, but visual inspection is usually</span>
<span class="sd">        best.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="c1"># Use centerline oversmoothing to find inflection points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">inflection_pts_oversmooth</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">n_infs</span><span class="o">=</span><span class="n">N</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">infsC</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;C&#39;</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">curvature</span><span class="p">()</span>

        <span class="c1"># Use curvature to find inflection points</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">infs_C</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">inflection_points</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">C</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">intersection_points</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="n">ls1</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">))</span>
        <span class="n">ls2</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">))</span>
        <span class="n">ls_intersections</span> <span class="o">=</span> <span class="n">ls1</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">ls2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unique</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sort</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">x1</span><span class="o">-</span><span class="n">pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">y1</span><span class="o">-</span><span class="n">pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="k">for</span> <span class="n">pt</span> <span class="ow">in</span> <span class="n">ls_intersections</span><span class="p">]))</span> <span class="c1"># locations of zero migration</span>

        <span class="c1"># Map the intersection points so that there is one point for every</span>
        <span class="c1"># pair of inflection points in inf_os</span>
        <span class="c1"># If there is only one intersection point, use it.</span>
        <span class="c1"># If none, use the first inflection point?</span>
        <span class="c1"># If multiple, use the one closest to the first inflection point</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;infs_os&#39;</span><span class="p">):</span>

            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>

            <span class="c1"># Compute the average bend length from the inflection points</span>
            <span class="n">ints</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
<span class="c1">#            abl = (s[self.infs_os[-1]] - s[self.infs_os[0]])/(len(self.infs_os)-1)</span>

            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">)):</span>

                <span class="n">i0</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>

                <span class="c1"># Find nearest intersection point for first inflection</span>
                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">intidx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i0</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">]))</span>
                    <span class="n">ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">[</span><span class="n">intidx</span><span class="p">])</span>

                <span class="c1"># Else find the nearest interesection point that is downstream of the bend&#39;s first inflection point</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">possible_ints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span> <span class="o">&gt;</span> <span class="n">ints</span><span class="p">[</span><span class="n">i</span><span class="o">-</span><span class="mi">1</span><span class="p">]]</span>
                    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">possible_ints</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">i0</span><span class="p">])</span>
                    <span class="n">ints</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">possible_ints</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">dists</span><span class="p">)])</span>

                <span class="k">if</span> <span class="n">i</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">:</span>
                    <span class="k">break</span>

            <span class="bp">self</span><span class="o">.</span><span class="n">ints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">ints</span><span class="p">)</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Could not map intersections to inflection point pairs because infs_os not computed. Run infs() first.&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">mig_rate_transect_matching</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">dt_years</span><span class="p">,</span> <span class="n">path_matchers</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">mig_spacing</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">path_mig_vectors</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute migration rate using &quot;transect matching&quot;. Requires a user to</span>
<span class="sd">        provide a geovector file (e.g. shapefile, geopackage, etc.) of that</span>
<span class="sd">        contains transects that intersect both centerlines at their common</span>
<span class="sd">        points.</span>

<span class="sd">        Also computes a smoothed version of the migration rates, and a smoothed</span>
<span class="sd">        version with cutoff-affected points set to NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># If no migration rate smoothing parameter is provided, use the same</span>
        <span class="c1"># one used for smoothing curvatures, else window size is 5.</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_C&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">window</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># must be greater than the polyorder, which is 3 by default</span>

        <span class="k">if</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="c1"># If no spacing is provided, use 1/8 channel width</span>
        <span class="k">if</span> <span class="n">mig_spacing</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">mig_spacing</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span><span class="o">/</span><span class="mi">8</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm</span><span class="p">,</span> <span class="n">pts_cl1</span><span class="p">,</span> <span class="n">pts_cl2</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">cl_migration_transect_matching</span><span class="p">(</span><span class="n">path_matchers</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">dt_years</span><span class="p">,</span> <span class="n">mig_spacing</span><span class="p">)</span>

        <span class="c1"># Export migration vectors if path provided</span>
        <span class="k">if</span> <span class="n">path_mig_vectors</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">crs</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Cannot export migration vectors until crs is set.&#39;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Migration vectors export</span>
                <span class="n">mvs</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">for</span> <span class="n">p1</span><span class="p">,</span> <span class="n">p2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">pts_cl1</span><span class="p">,</span> <span class="n">pts_cl2</span><span class="p">):</span>
                    <span class="n">mvs</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">LineString</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p2</span><span class="p">)))</span>
                <span class="n">gdf_mvs</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">GeoDataFrame</span><span class="p">(</span><span class="n">geometry</span><span class="o">=</span><span class="n">mvs</span><span class="p">,</span> <span class="n">crs</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">crs</span><span class="p">)</span>
                <span class="n">gdf_mvs</span><span class="o">.</span><span class="n">to_file</span><span class="p">(</span><span class="n">path_mig_vectors</span><span class="p">,</span> <span class="n">driver</span><span class="o">=</span><span class="n">io</span><span class="o">.</span><span class="n">get_driver</span><span class="p">(</span><span class="n">path_mig_vectors</span><span class="p">))</span>


        <span class="c1"># Smooth the migration rates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mr_tm</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                             <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

        <span class="c1"># Set cutoff-affected and erodibility-affected bends to NaN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_nan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_sm_nan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_sm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cut_ids&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_sm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;erode_ids&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">erode_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_tm_sm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>


    <span class="k">def</span> <span class="nf">mig_rate_zs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">dt_years</span><span class="p">,</span> <span class="n">x1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y1</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute migration rate using Sylvester et al&#39;s method of</span>
<span class="sd">        dynamic time warping. Also computes a smoothed version of the</span>
<span class="sd">        migration rates, and a smoothed version with cutoff-affected</span>
<span class="sd">        points set to NaN.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x1</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x1</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>

        <span class="c1"># If no migration rate smoothing parameter is provided, use the same</span>
        <span class="c1"># one used for smoothing curvatures, else window size is 5.</span>
        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_C&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">window</span> <span class="o">=</span> <span class="mi">5</span>  <span class="c1"># must be greater than the polyorder, which is 3 by default</span>

        <span class="kn">import</span> <span class="nn">os</span>
        <span class="kn">import</span> <span class="nn">sys</span>
        <span class="n">script_dir</span> <span class="o">=</span> <span class="sa">r</span><span class="s2">&quot;C:\Users\Jon\Desktop\Research\Koyukukon\Normalize migration rates\Code\curvaturepy-master&quot;</span>
        <span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">script_dir</span><span class="p">))</span>
        <span class="kn">import</span> <span class="nn">cline_analysis</span> <span class="k">as</span> <span class="nn">ca</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">mrs_zs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">p_zs</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">q_zs</span> <span class="o">=</span> <span class="n">ca</span><span class="o">.</span><span class="n">get_migr_rate</span><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">y1</span><span class="p">,</span> <span class="n">y2</span><span class="p">,</span> <span class="n">dt_years</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

        <span class="c1"># Smooth the migration rates</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mr_zs</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window</span><span class="p">,</span>
                                             <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

        <span class="c1"># Set cutoff-affected and erodibility-affected bends to NaN</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm_nan</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm</span><span class="o">.</span><span class="n">copy</span><span class="p">()</span>
        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cut_ids&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">c</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;erode_ids&#39;</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">erode_ids</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_sm_nan</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="p">]:</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">[</span><span class="n">e</span><span class="o">+</span><span class="mi">1</span><span class="p">]]</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">NaN</span>


    <span class="k">def</span> <span class="nf">plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">y</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>

        <span class="k">if</span> <span class="n">x</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">version</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__get_x_and_y</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">version</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">()</span>
        <span class="n">legend</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="s1">&#39;k&#39;</span><span class="p">)</span>
        <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">version</span> <span class="o">+</span> <span class="s1">&#39; centerline&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;infs_os&#39;</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span><span class="p">],</span> <span class="s1">&#39;rs&#39;</span><span class="p">)</span>
            <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;inflection points&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ints_all&#39;</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">],</span>  <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints_all</span><span class="p">],</span> <span class="s1">&#39;go&#39;</span><span class="p">)</span>
            <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;intersection points&#39;</span><span class="p">)</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ints&#39;</span><span class="p">):</span>
            <span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints</span><span class="p">],</span> <span class="n">y</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">ints</span><span class="p">],</span> <span class="s1">&#39;b^&#39;</span><span class="p">)</span>
            <span class="n">legend</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;intersection points (mapped)&#39;</span><span class="p">)</span>

        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">legend</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">axis</span><span class="p">(</span><span class="s1">&#39;equal&#39;</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">zs_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">window</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Copied verbatim from https://github.com/zsylvester/curvaturepy/blob/master/Purus_2_migration_rates.ipynb</span>
<span class="sd">        Slight modifications for meshing in the centerline class.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;infs_os&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Must compute inflection points first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;ints&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Must compute intersections first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;mr_zs_nan&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Must compute migration rates first.&#39;</span><span class="p">)</span>
            <span class="k">return</span>
<span class="c1">#            elif hasattr(self, &#39;mr_zs_sm_nan&#39;):</span>
<span class="c1">#                migr_rate = self.mr_zs_sm_nan</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">migr_rate</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">mr_zs_nan</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;cut_ids&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">cutoff_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cutoff_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">cut_ids</span>

        <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;erode_ids&#39;</span><span class="p">)</span> <span class="ow">is</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">erodibility_inds</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">erodibility_inds</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">erode_ids</span>

        <span class="k">if</span> <span class="n">window</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">hasattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s1">&#39;window_C&#39;</span><span class="p">):</span>
                <span class="n">window</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_C</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Must provide a smoothing window.&#39;</span><span class="p">)</span>
                <span class="k">return</span>

        <span class="n">LZC</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">infs_os</span>
        <span class="n">LZM</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">ints</span>
        <span class="n">s</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">s</span><span class="p">()</span>
        <span class="n">curv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">Csmooth</span><span class="p">()</span>
        <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">W</span>

        <span class="n">fig</span><span class="p">,</span> <span class="n">ax1</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">18</span><span class="p">,</span><span class="mi">4</span><span class="p">))</span>
<span class="c1">#            plt.tight_layout()</span>

        <span class="n">y1</span> <span class="o">=</span> <span class="mf">0.7</span>
        <span class="n">y2</span> <span class="o">=</span> <span class="mf">0.0</span>
        <span class="n">y3</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.87</span>
        <span class="n">y4</span> <span class="o">=</span> <span class="o">-</span><span class="mf">1.25</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">0.85</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">curv</span><span class="o">*</span><span class="n">W</span><span class="p">)</span>
        <span class="n">ax2</span> <span class="o">=</span> <span class="n">ax1</span><span class="o">.</span><span class="n">twinx</span><span class="p">()</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">fill_between</span><span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">migr_rate</span><span class="p">,</span> <span class="n">facecolor</span><span class="o">=</span><span class="s1">&#39;green&#39;</span><span class="p">)</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">plot</span><span class="p">([</span><span class="mi">0</span><span class="p">,</span><span class="nb">max</span><span class="p">(</span><span class="n">s</span><span class="p">)],[</span><span class="mi">0</span><span class="p">,</span><span class="mi">0</span><span class="p">],</span><span class="s1">&#39;k--&#39;</span><span class="p">)</span>

        <span class="n">ax1</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="n">y4</span><span class="p">,</span><span class="n">y1</span><span class="p">)</span>
        <span class="n">ax2</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">(</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">40</span><span class="p">)</span>
        <span class="n">ax1</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="mi">0</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">erodibility_inds</span><span class="p">:</span>
            <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">0.85</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">cutoff_inds</span><span class="p">:</span>
            <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
            <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="p">[</span><span class="mf">0.85</span><span class="p">,</span><span class="mf">1.0</span><span class="p">,</span><span class="mf">0.85</span><span class="p">],</span><span class="n">zorder</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">migr_rate</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">y1</span><span class="p">,</span><span class="n">y1</span><span class="p">,</span><span class="n">y2</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y4</span><span class="p">,</span><span class="n">y3</span><span class="p">,</span><span class="n">y2</span><span class="p">]</span>
                <span class="n">ax1</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">migr_rate</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]:</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]]))</span><span class="o">&gt;</span><span class="mi">0</span><span class="p">:</span>
                <span class="n">xcoords</span> <span class="o">=</span> <span class="p">[</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZM</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]]]</span>
                <span class="n">ycoords</span> <span class="o">=</span> <span class="p">[</span><span class="mi">35</span><span class="p">,</span><span class="mi">35</span><span class="p">,</span><span class="mf">20.7145</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="o">-</span><span class="mi">15</span><span class="p">,</span><span class="mi">0</span><span class="p">,</span><span class="mf">20.7145</span><span class="p">]</span>
                <span class="n">ax2</span><span class="o">.</span><span class="n">fill</span><span class="p">(</span><span class="n">xcoords</span><span class="p">,</span><span class="n">ycoords</span><span class="p">,</span><span class="n">color</span><span class="o">=</span><span class="s1">&#39;w&#39;</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="n">LZC</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">ax1</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">LZC</span><span class="p">[</span><span class="n">i</span><span class="p">]],</span><span class="mf">0.5</span><span class="p">,</span><span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="p">),</span><span class="n">fontsize</span><span class="o">=</span><span class="mi">12</span><span class="p">)</span>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, J. Schwenk &amp; J. Hariharan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>