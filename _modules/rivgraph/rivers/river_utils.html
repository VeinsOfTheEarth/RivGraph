<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>rivgraph.rivers.river_utils &mdash; RivGraph 0.5.0 documentation</title>
      <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-binder.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-dataframe.css" type="text/css" />
      <link rel="stylesheet" href="../../../_static/sg_gallery-rendered-html.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../../../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../../../" id="documentation_options" src="../../../_static/documentation_options.js"></script>
        <script src="../../../_static/jquery.js"></script>
        <script src="../../../_static/underscore.js"></script>
        <script src="../../../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../../../_static/doctools.js"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
            <a href="../../../index.html">
            <img src="../../../_static/rg_logo_full.png" class="logo" alt="Logo"/>
          </a>
              <div class="version">
                0.5.0
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../quickstart/index.html">Quickstart</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../background/index.html">Background</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../install/index.html">Installation Instructions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../examples/index.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../maskmaking/index.html">Maskmaking</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../shoreline/index.html">Shoreline creation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../linksnodes/index.html">Link and Node Dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../issues/index.html">Known issues</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../featuredevelopment/index.html">Feature Development</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../contributing/index.html">Contributing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../gallery/index.html">RivGraph in the wild</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../apiref/index.html">API Reference</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">RivGraph</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home"></a> &raquo;</li>
          <li><a href="../../index.html">Module code</a> &raquo;</li>
      <li>rivgraph.rivers.river_utils</li>
      <li class="wy-breadcrumbs-aside">
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <h1>Source code for rivgraph.rivers.river_utils</h1><div class="highlight"><pre>
<span></span><span class="c1"># -*- coding: utf-8 -*-</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="sd">river_utils</span>
<span class="sd">===========</span>

<span class="sd">Created on Tue Nov  6 14:29:10 2018</span>

<span class="sd">@author: Jon</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">networkx</span> <span class="k">as</span> <span class="nn">nx</span>
<span class="kn">from</span> <span class="nn">fastdtw</span> <span class="kn">import</span> <span class="n">fastdtw</span>
<span class="kn">from</span> <span class="nn">scipy.ndimage.morphology</span> <span class="kn">import</span> <span class="n">distance_transform_edt</span>
<span class="kn">import</span> <span class="nn">shapely</span>
<span class="kn">from</span> <span class="nn">shapely.geometry</span> <span class="kn">import</span> <span class="n">LineString</span><span class="p">,</span> <span class="n">Polygon</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="kn">import</span> <span class="n">signal</span>
<span class="kn">from</span> <span class="nn">scipy.spatial.distance</span> <span class="kn">import</span> <span class="n">cdist</span><span class="p">,</span> <span class="n">euclidean</span>
<span class="kn">from</span> <span class="nn">matplotlib</span> <span class="kn">import</span> <span class="n">pyplot</span> <span class="k">as</span> <span class="n">plt</span>
<span class="kn">import</span> <span class="nn">geopandas</span> <span class="k">as</span> <span class="nn">gpd</span>

<span class="kn">from</span> <span class="nn">rivgraph.ordered_set</span> <span class="kn">import</span> <span class="n">OrderedSet</span>
<span class="kn">import</span> <span class="nn">rivgraph.im_utils</span> <span class="k">as</span> <span class="nn">iu</span>
<span class="kn">import</span> <span class="nn">rivgraph.mask_to_graph</span> <span class="k">as</span> <span class="nn">m2g</span>
<span class="kn">import</span> <span class="nn">rivgraph.ln_utils</span> <span class="k">as</span> <span class="nn">lnu</span>
<span class="kn">import</span> <span class="nn">rivgraph.rivers.centerline_utils</span> <span class="k">as</span> <span class="nn">cu</span>


<div class="viewcode-block" id="prune_river"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.prune_river">[docs]</a><span class="k">def</span> <span class="nf">prune_river</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">exit_sides</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">,</span> <span class="n">gdobj</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Prune river network.&quot;&quot;&quot;</span>
    <span class="c1"># Get inlet nodes</span>
    <span class="n">nodes</span> <span class="o">=</span> <span class="n">find_inlet_outlet_nodes</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">exit_sides</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">)</span>

    <span class="c1"># Remove spurs from network (this includes valid inlets and outlets unless</span>
    <span class="c1"># specified not to remove)</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">remove_all_spurs</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span>
                                        <span class="n">dontremove</span><span class="o">=</span><span class="nb">list</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;inlets&#39;</span><span class="p">]</span> <span class="o">+</span>
                                                        <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;outlets&#39;</span><span class="p">]))</span>

    <span class="c1"># # Add artificial nodes where necessary</span>
    <span class="c1"># links, nodes = lnu.add_artificial_nodes(links, nodes, gdobj)</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">find_parallel_links</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="c1"># Remove sets of links that are disconnected from inlets/outlets except</span>
    <span class="c1"># for a single bridge link (effectively re-pruning the network)</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">remove_disconnected_bridge_links</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="c1"># Remove one-pixel links</span>
    <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">remove_single_pixel_links</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">links</span><span class="p">,</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="find_inlet_outlet_nodes"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.find_inlet_outlet_nodes">[docs]</a><span class="k">def</span> <span class="nf">find_inlet_outlet_nodes</span><span class="p">(</span><span class="n">links</span><span class="p">,</span> <span class="n">nodes</span><span class="p">,</span> <span class="n">exit_sides</span><span class="p">,</span> <span class="n">Iskel</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Append inlet and outlet nodes to the node dictionary.</span>

<span class="sd">    Appends the inlet and outlet nodes to the nodes dictionary. Only works for</span>
<span class="sd">    rivers; deltas must be treated differently.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Find possible inlet/outlet link candidates as those attached to a node</span>
    <span class="c1"># of degree-1.</span>
    <span class="n">poss_endlinks</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">nconn</span> <span class="ow">in</span> <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">]:</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nconn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">poss_endlinks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nconn</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Find the row(s)/column(s) corresponding to extent of the river at the</span>
    <span class="c1"># exit sides</span>
    <span class="n">pixy</span><span class="p">,</span> <span class="n">pixx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Iskel</span> <span class="o">==</span> <span class="kc">True</span><span class="p">)</span>
    <span class="n">e</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="n">n</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pixx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pixx</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">min</span><span class="p">(</span><span class="n">pixy</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">pixy</span><span class="p">)</span>

    <span class="c1"># Get row, column coordinates of all nodes endpoints</span>
    <span class="n">n_r</span><span class="p">,</span> <span class="n">n_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">],</span> <span class="n">Iskel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Find inlets and outlets by searching for nodes that intersect the first</span>
    <span class="c1"># exit_side of the image</span>
    <span class="n">ins_outs</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_r</span> <span class="o">==</span> <span class="n">n</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_r</span> <span class="o">==</span> <span class="n">s</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_c</span> <span class="o">==</span> <span class="n">e</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="n">j</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">n_c</span> <span class="o">==</span> <span class="n">w</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>

        <span class="n">ins_outs</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">idcs</span><span class="p">])</span>

    <span class="c1"># If there were no inlet or outlet nodes found, take the possible</span>
    <span class="c1"># inlet/outlet that is closest to the corresponding exit side as the</span>
    <span class="c1"># inlet/outlet node</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ins_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">s</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">e</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">w</span><span class="p">))</span>
        <span class="n">ins_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">idcs</span><span class="p">]]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ins_outs</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">n</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_r</span><span class="o">-</span><span class="n">s</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">e</span><span class="p">))</span>
        <span class="k">elif</span> <span class="n">exit_sides</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
            <span class="n">idcs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">n_c</span><span class="o">-</span><span class="n">w</span><span class="p">))</span>
        <span class="n">ins_outs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">][</span><span class="n">idcs</span><span class="p">]]</span>

    <span class="c1"># Append inlets and outlets to nodes dictionary</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;inlets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins_outs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;outlets&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">ins_outs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;inlets&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No inlet nodes found.&#39;</span><span class="p">)</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nodes</span><span class="p">[</span><span class="s1">&#39;outlets&#39;</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
        <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;No outlet nodes found.&#39;</span><span class="p">)</span>

    <span class="c1"># TODO: handle special cases where the link intersects the edge of the</span>
    <span class="c1"># image but the node does not because the link is a loop. This might be</span>
    <span class="c1"># &quot;fixable&quot; by adjusting the padding multiplier; I don&#39;t have any test</span>
    <span class="c1"># cases to work on currently so leaving this unimplemented for now.</span>

    <span class="k">return</span> <span class="n">nodes</span></div>


<div class="viewcode-block" id="mask_to_centerline"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.mask_to_centerline">[docs]</a><span class="k">def</span> <span class="nf">mask_to_centerline</span><span class="p">(</span><span class="n">Imask</span><span class="p">,</span> <span class="n">es</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Extract centerline from a river mask.</span>

<span class="sd">    This function takes an input binary mask of a river and extracts its</span>
<span class="sd">    centerline. If there are multiple channels (and therefore islands) in the</span>
<span class="sd">    river, they will be filled before the centerline is computed.</span>

<span class="sd">    .. note:: The input mask should have the following properties:</span>

<span class="sd">        1) There should be only one &quot;blob&quot; (connected component)</span>

<span class="sd">        2) Where the blob intersects the image edges, there should be only</span>
<span class="sd">           one channel. This avoids ambiguity in identifying inlet/outlet links</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Imask : ndarray</span>
<span class="sd">        the mask image (numpy array)</span>
<span class="sd">    es : str</span>
<span class="sd">        two-character string comprinsed of &quot;n&quot;, &quot;e&quot;, &quot;s&quot;, or &quot;w&quot;. Exit sides</span>
<span class="sd">        correspond to the sides of the image that the river intersects.</span>
<span class="sd">        Upstream should be first, followed by downstream.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    dt.tif : geotiff</span>
<span class="sd">        geotiff of the distance transform of the binary mask</span>
<span class="sd">    skel.tif : geotiff</span>
<span class="sd">        geotiff of the skeletonized binary mask</span>
<span class="sd">    centerline.shp : shp</span>
<span class="sd">        shapefile of the centerline, arranged upstream to downstream</span>
<span class="sd">    cl.pkl : pkl</span>
<span class="sd">        pickle file containing centerline coords, EPSG, and paths dictionary</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Lowercase the exit sides</span>
    <span class="n">es</span> <span class="o">=</span> <span class="n">es</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span>

    <span class="c1"># Keep only largest connected blob</span>
    <span class="n">I</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Imask</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>

    <span class="c1"># Fill holes in mask</span>
    <span class="n">Ihf</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">I</span><span class="p">)</span>

    <span class="c1"># Skeletonize holes-filled river image</span>
    <span class="n">Ihf_skel</span> <span class="o">=</span> <span class="n">m2g</span><span class="o">.</span><span class="n">skeletonize_river_mask</span><span class="p">(</span><span class="n">Ihf</span><span class="p">,</span> <span class="n">es</span><span class="p">)</span>

    <span class="c1"># In some cases, skeleton spurs can prevent the creation of an endpoint</span>
    <span class="c1"># at the edge of the image. This next block of code tries to condition</span>
    <span class="c1"># the skeleton to prevent this from happening.</span>
    <span class="c1"># Find skeleton border pixels</span>
    <span class="n">skel_rows</span><span class="p">,</span> <span class="n">skel_cols</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">)</span>
    <span class="n">idcs_top</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_rows</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">idcs_bottom</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_rows</span> <span class="o">==</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idcs_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_cols</span> <span class="o">==</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">idcs_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">skel_cols</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="c1"># Remove skeleton border pixels</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="c1"># Remove all pixels now disconnected from the main skeleton</span>
    <span class="n">Ihf_skel</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>
    <span class="c1"># Add the border pixels back</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_top</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_bottom</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_right</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>
    <span class="n">Ihf_skel</span><span class="p">[</span><span class="n">skel_rows</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">],</span> <span class="n">skel_cols</span><span class="p">[</span><span class="n">idcs_left</span><span class="p">]]</span> <span class="o">=</span> <span class="mi">1</span>

    <span class="c1"># Keep only the largest connected skeleton</span>
    <span class="n">Ihf_skel</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>

    <span class="c1"># Convert skeleton to graph</span>
    <span class="n">hf_links</span><span class="p">,</span> <span class="n">hf_nodes</span> <span class="o">=</span> <span class="n">m2g</span><span class="o">.</span><span class="n">skel_to_graph</span><span class="p">(</span><span class="n">Ihf_skel</span><span class="p">)</span>

    <span class="c1"># Compute holes-filled distance transform</span>
    <span class="n">Ihf_dist</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">Ihf</span><span class="p">)</span>  <span class="c1"># distance transform</span>

    <span class="c1"># Append link widths and lengths</span>
    <span class="n">hf_links</span> <span class="o">=</span> <span class="n">lnu</span><span class="o">.</span><span class="n">link_widths_and_lengths</span><span class="p">(</span><span class="n">hf_links</span><span class="p">,</span> <span class="n">Ihf_dist</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot; Find shortest path between inlet/outlet centerline nodes&quot;&quot;&quot;</span>
    <span class="c1"># Put skeleton into networkX graph object</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">Graph</span><span class="p">()</span>
    <span class="n">G</span><span class="o">.</span><span class="n">add_nodes_from</span><span class="p">(</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">])</span>
    <span class="k">for</span> <span class="n">lc</span><span class="p">,</span> <span class="n">wt</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">],</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;len&#39;</span><span class="p">]):</span>
        <span class="n">G</span><span class="o">.</span><span class="n">add_edge</span><span class="p">(</span><span class="n">lc</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">lc</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">weight</span><span class="o">=</span><span class="n">wt</span><span class="p">)</span>

    <span class="c1"># Get endpoints of graph</span>
    <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">nid</span> <span class="k">for</span> <span class="n">nid</span><span class="p">,</span> <span class="n">nconn</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">],</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">])</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">nconn</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Filter endpoints if we have too many--shortest path compute time scales as a power of len(endpoints)</span>
    <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">endpoints</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">100</span><span class="p">:</span>
        <span class="n">ep_r</span><span class="p">,</span> <span class="n">ep_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">ep</span><span class="p">)]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">],</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
        <span class="n">pct</span> <span class="o">=</span> <span class="mi">10</span>
        <span class="n">ep_keep</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">esi</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">n_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_r</span><span class="p">,</span> <span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_r</span> <span class="o">&lt;=</span> <span class="n">n_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">s_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_r</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_r</span> <span class="o">&gt;=</span> <span class="n">s_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
                <span class="n">e_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_c</span><span class="p">,</span> <span class="mi">100</span><span class="o">-</span><span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_c</span> <span class="o">&gt;</span> <span class="n">e_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">esi</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="n">w_pct</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">percentile</span><span class="p">(</span><span class="n">ep_c</span><span class="p">,</span> <span class="n">pct</span><span class="p">))</span>
                <span class="n">ep_keep</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">ep_c</span> <span class="o">&lt;</span> <span class="n">w_pct</span><span class="p">)[</span><span class="mi">0</span><span class="p">])</span>

        <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[</span><span class="n">endpoints</span><span class="p">[</span><span class="n">ek</span><span class="p">]</span> <span class="k">for</span> <span class="n">ek</span> <span class="ow">in</span> <span class="n">ep_keep</span><span class="p">]</span>

    <span class="c1"># Get all paths from inlet(s) to outlets</span>
    <span class="n">longest_shortest_paths</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">inl</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
        <span class="n">temp_lens</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">o</span> <span class="ow">in</span> <span class="n">endpoints</span><span class="p">:</span>
            <span class="n">temp_lens</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path_length</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">inl</span><span class="p">,</span> <span class="n">o</span><span class="p">,</span>
                                                     <span class="n">weight</span><span class="o">=</span><span class="s1">&#39;weight&#39;</span><span class="p">))</span>
        <span class="n">longest_shortest_paths</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">max</span><span class="p">(</span><span class="n">temp_lens</span><span class="p">))</span>

    <span class="c1"># The two end nodes with the longest shortest path are the centerline&#39;s</span>
    <span class="c1"># endnodes</span>
    <span class="n">end_nodes_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isclose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">longest_shortest_paths</span><span class="p">),</span>
                                        <span class="n">longest_shortest_paths</span><span class="p">))[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">endpoints</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="n">end_nodes_idx</span><span class="p">]</span>

    <span class="c1"># It is possible that more than two endnodes were identified; in these</span>
    <span class="c1"># cases, choose the nodes that are farthest apart in Euclidean space</span>
    <span class="n">en_r</span><span class="p">,</span> <span class="n">en_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">en</span><span class="p">)]</span> <span class="k">for</span> <span class="n">en</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">],</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">ep_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;1,2,0&#39;</span><span class="p">,</span> <span class="n">en_r</span><span class="p">,</span> <span class="n">en_c</span><span class="p">]</span>
    <span class="n">ep_dists</span> <span class="o">=</span> <span class="n">cdist</span><span class="p">(</span><span class="n">ep_coords</span><span class="p">,</span> <span class="n">ep_coords</span><span class="p">,</span> <span class="s1">&#39;euclidean&#39;</span><span class="p">)</span>
    <span class="n">en_idcs_to_use</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">ep_dists</span><span class="p">),</span> <span class="n">ep_dists</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>
    <span class="n">end_nodes</span> <span class="o">=</span> <span class="p">[</span><span class="n">end_nodes</span><span class="p">[</span><span class="n">eitu</span><span class="p">]</span> <span class="k">for</span> <span class="n">eitu</span> <span class="ow">in</span> <span class="n">en_idcs_to_use</span><span class="p">]</span>

    <span class="c1"># Ensure that exactly two end nodes are identified</span>
    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">2</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">{}</span><span class="s1"> endpoints were found for the centerline. (Need exactly two).&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">)))</span>

    <span class="c1"># Find upstream node</span>
    <span class="n">en_r</span><span class="p">,</span> <span class="n">en_c</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">([</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">n</span><span class="p">)]</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">end_nodes</span><span class="p">],</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Compute error for each end node given the exit sides</span>
    <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">orientation</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">orientation</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">er</span> <span class="o">=</span> <span class="n">en_r</span>
            <span class="n">ec</span> <span class="o">=</span> <span class="n">en_c</span>
        <span class="k">elif</span> <span class="n">orientation</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">er</span> <span class="o">=</span> <span class="n">en_r</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ec</span> <span class="o">=</span> <span class="n">en_c</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">err</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">ot</span> <span class="ow">in</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]:</span>
            <span class="k">if</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;n&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">er</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;s&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">Ihf_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">er</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;w&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">ec</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
            <span class="k">elif</span> <span class="n">es</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span><span class="o">.</span><span class="n">lower</span><span class="p">()</span> <span class="o">==</span> <span class="s1">&#39;e&#39;</span><span class="p">:</span>
                <span class="n">err</span> <span class="o">=</span> <span class="n">err</span> <span class="o">+</span> <span class="n">Ihf_dist</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">ec</span><span class="p">[</span><span class="n">ot</span><span class="p">]</span>
        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
    <span class="c1"># Flip end node orientation to get US-&gt;DS arrangement</span>
    <span class="k">if</span> <span class="n">errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">errors</span><span class="p">[</span><span class="mi">1</span><span class="p">]:</span>
        <span class="n">end_nodes</span> <span class="o">=</span> <span class="n">end_nodes</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Create centerline from links along shortest path</span>
    <span class="n">nodespath</span> <span class="o">=</span> <span class="n">nx</span><span class="o">.</span><span class="n">dijkstra_path</span><span class="p">(</span><span class="n">G</span><span class="p">,</span> <span class="n">end_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">end_nodes</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># nodes shortest path</span>
    <span class="c1"># Find the links along the shortest node path</span>
    <span class="n">cl_link_ids</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">u</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">nodespath</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span> <span class="n">nodespath</span><span class="p">[</span><span class="mi">1</span><span class="p">:]):</span>
        <span class="n">ulinks</span> <span class="o">=</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">u</span><span class="p">)]</span>
        <span class="n">vlinks</span> <span class="o">=</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;conn&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">v</span><span class="p">)]</span>
        <span class="n">cl_link_ids</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">ul</span> <span class="k">for</span> <span class="n">ul</span> <span class="ow">in</span> <span class="n">ulinks</span> <span class="k">if</span> <span class="n">ul</span> <span class="ow">in</span> <span class="n">vlinks</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>

    <span class="c1"># Create a shortest-path links dict</span>
    <span class="n">cl_links</span> <span class="o">=</span> <span class="nb">dict</span><span class="o">.</span><span class="n">fromkeys</span><span class="p">(</span><span class="n">hf_links</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">dokeys</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">hf_links</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="n">dokeys</span><span class="o">.</span><span class="n">remove</span><span class="p">(</span><span class="s1">&#39;n_networks&#39;</span><span class="p">)</span>  <span class="c1"># Don&#39;t need n_networks</span>
    <span class="k">for</span> <span class="n">clid</span> <span class="ow">in</span> <span class="n">cl_link_ids</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">dokeys</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">cl_links</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">cl_links</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">cl_links</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">hf_links</span><span class="p">[</span><span class="n">k</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">clid</span><span class="p">)])</span>

    <span class="c1"># Save centerline as shapefile</span>
<span class="c1">#    lnu.links_to_shapefile(cl_links, igd, rmh.get_EPSG(paths[&#39;skel&#39;]), paths[&#39;cl_temp_shp&#39;])</span>

    <span class="c1"># Get and save coordinates of centerline</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ic</span><span class="p">,</span> <span class="n">cll</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">cl_link_ids</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">ic</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_nodes</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">end_nodes</span><span class="p">[</span><span class="mi">0</span><span class="p">])]:</span>
                <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)]</span> <span class="o">=</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][</span><span class="mi">0</span><span class="p">]</span> <span class="o">!=</span> <span class="n">cl</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]:</span>
                <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)]</span> <span class="o">=</span> <span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">cl</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;idx&#39;</span><span class="p">][</span><span class="n">hf_links</span><span class="p">[</span><span class="s1">&#39;id&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">cll</span><span class="p">)][:])</span>

    <span class="c1"># Uniquify points, preserving order</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">OrderedSet</span><span class="p">(</span><span class="n">cl</span><span class="p">))</span>

    <span class="c1"># Convert back to coordinates</span>
    <span class="n">cly</span><span class="p">,</span> <span class="n">clx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">unravel_index</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">Ihf_skel</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

    <span class="c1"># Get width at each pixel of centerline</span>
    <span class="n">pix_width</span> <span class="o">=</span> <span class="p">[</span><span class="n">Ihf_dist</span><span class="p">[</span><span class="n">y</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span><span class="o">*</span><span class="mi">2</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">clx</span><span class="p">,</span> <span class="n">cly</span><span class="p">)]</span>

    <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">clx</span><span class="p">,</span> <span class="n">cly</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">coords</span><span class="p">,</span> <span class="n">pix_width</span></div>


<div class="viewcode-block" id="centerline_mesh"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.centerline_mesh">[docs]</a><span class="k">def</span> <span class="nf">centerline_mesh</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">width_chan</span><span class="p">,</span> <span class="n">meshwidth</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span> <span class="n">smoothing_param</span><span class="o">=</span><span class="mi">1</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a centerline mesh.</span>

<span class="sd">    Generates a centerline mesh. Differs from :func:`valleyline_mesh` in that</span>
<span class="sd">    it draws perpendiculars rather than offsetting the valley line to compute</span>
<span class="sd">    mesh polygons. This method is more effective for narrower channels that</span>
<span class="sd">    don&#39;t require an exceptionally wide mesh (i.e. not much change).</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords :</span>
<span class="sd">        2xN list, tuple, np.array (xs, ys) of coordinates defining centerline</span>
<span class="sd">    width_chan :</span>
<span class="sd">        width of the river in same units of coords</span>
<span class="sd">    mesh_dist :</span>
<span class="sd">        how wide should the mesh be, in same units of coords</span>
<span class="sd">    grid_spacing :</span>
<span class="sd">        how far apart should mesh cells be, in same units of coords</span>

<span class="sd">    &quot;&quot;&quot;</span>
<span class="c1">#    coords = ken.centerline</span>
<span class="c1">#    width_chan = ken.width_chans</span>
<span class="c1">#    meshwidth = ken.max_valley_width_pixels * ken.pixlen * 1.1</span>
<span class="c1">#    grid_spacing = meshwidth/10</span>
<span class="c1">#    smoothing_param = 1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="c1"># Get lengths along centerline</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">s_ds</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">])</span>

    <span class="c1"># Mirror centerline manually since scipy fucks it up - only flip the axis that has the largest displacement</span>
    <span class="c1"># Mirroring done to avoid edge effects when smoothing</span>
    <span class="n">npad</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width_chan</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>  <span class="c1"># Padding fixed at 10 channel widths</span>
    <span class="n">xs_m</span><span class="p">,</span> <span class="n">ys_m</span> <span class="o">=</span> <span class="n">mirror_line_ends</span><span class="p">(</span><span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">npad</span><span class="p">)</span>

    <span class="c1"># A smoothing filter of one-channel width will be passed over the centerline coordinates</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">width_chan</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ds</span><span class="p">)</span> <span class="o">*</span> <span class="n">smoothing_param</span><span class="p">)</span>
    <span class="k">if</span> <span class="n">window_len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Window must be odd</span>
        <span class="n">window_len</span> <span class="o">=</span> <span class="n">window_len</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Smooth</span>
    <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">xs_m</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
    <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">ys_m</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

    <span class="c1"># plt.close(&#39;all&#39;)</span>
    <span class="c1"># plt.plot(xs_sm, ys_sm)</span>
    <span class="c1"># plt.plot(xs_m, ys_m)</span>
    <span class="c1"># plt.axis(&#39;equal&#39;)</span>

    <span class="c1"># Re-sample centerline to even spacing</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">s_ds</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">)</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">/</span><span class="n">grid_spacing</span><span class="p">)</span>
    <span class="n">xy_rs</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">evenly_space_line</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">,</span> <span class="n">npts</span><span class="p">)</span>
    <span class="n">xs_rs</span> <span class="o">=</span> <span class="n">xy_rs</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_rs</span> <span class="o">=</span> <span class="n">xy_rs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Get angles at each point along centerline</span>
    <span class="n">C</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">curvars</span><span class="p">(</span><span class="n">xs_rs</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">,</span> <span class="n">unwrap</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

    <span class="c1"># Draw perpendiculars at each centerline point</span>
    <span class="n">mesh_hwidth</span> <span class="o">=</span> <span class="n">meshwidth</span><span class="o">/</span><span class="mi">2</span>

    <span class="c1"># Compute slope of perpendicular (w/ref to dx/dy and dy/dx)</span>
    <span class="n">m_inv_xy</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_rs</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_rs</span><span class="p">))</span>
    <span class="n">m_inv_yx</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">/</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_rs</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_rs</span><span class="p">))</span>
    <span class="c1"># For storing perpendicular points</span>
    <span class="n">perps</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">ic</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">m_inv_xy</span><span class="p">)):</span>

        <span class="c1"># Compute perpendicular lines based on largest of dx, dy (reduces distortion)</span>
        <span class="k">if</span> <span class="n">m_inv_yx</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">&gt;</span> <span class="n">m_inv_xy</span><span class="p">[</span><span class="n">ic</span><span class="p">]:</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mesh_hwidth</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">m_inv_yx</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">dx</span> <span class="o">*</span> <span class="n">m_inv_yx</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">mesh_hwidth</span><span class="o">**</span><span class="mi">2</span><span class="o">/</span><span class="p">(</span><span class="mi">1</span><span class="o">+</span><span class="n">m_inv_xy</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">dy</span> <span class="o">*</span> <span class="n">m_inv_xy</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span>

        <span class="n">upper_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">+</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">+</span> <span class="n">dy</span><span class="p">)</span>
        <span class="n">lower_pt</span> <span class="o">=</span> <span class="p">(</span><span class="n">xs_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">-</span> <span class="n">dx</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">[</span><span class="n">ic</span><span class="p">]</span> <span class="o">-</span> <span class="n">dy</span><span class="p">)</span>

        <span class="n">perps</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">upper_pt</span><span class="p">,</span> <span class="n">lower_pt</span><span class="p">))</span>

    <span class="c1"># Now orient perpendiculars so that both sides are continuous</span>
    <span class="c1"># NOTE: this method is not guaranteed to work when the grid spacing is much</span>
    <span class="c1"># larger than the buffer width (it likely will be fine, but for highly-</span>
    <span class="c1"># curved bends failure is possible). There are more robust ways to separate</span>
    <span class="c1"># points into left/right bank, but this is quick, dirty, and works for most</span>
    <span class="c1"># applications.</span>
    <span class="n">perp_aligned</span> <span class="o">=</span> <span class="p">[</span><span class="n">perps</span><span class="p">[</span><span class="mi">0</span><span class="p">]]</span>
    <span class="k">for</span> <span class="n">ip</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">perps</span><span class="p">)):</span>

        <span class="n">left_pre</span><span class="p">,</span> <span class="n">right_pre</span> <span class="o">=</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">ip</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

        <span class="n">p0</span> <span class="o">=</span> <span class="n">perps</span><span class="p">[</span><span class="n">ip</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">p1</span> <span class="o">=</span> <span class="n">perps</span><span class="p">[</span><span class="n">ip</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>

        <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p0</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p0</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;</span>  <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">p1</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">(</span><span class="n">p1</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">left_pre</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">):</span>
            <span class="n">perp_aligned</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p0</span><span class="p">,</span> <span class="n">p1</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">perp_aligned</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">p1</span><span class="p">,</span> <span class="n">p0</span><span class="p">))</span>

    <span class="c1"># plt.close(&#39;all&#39;)</span>
    <span class="c1"># plt.plot(xs_rs, ys_rs,&#39;.&#39;)</span>
    <span class="c1"># plt.axis(&#39;equal&#39;)</span>
    <span class="c1"># for p in perp_aligned:</span>
    <span class="c1">#     plt.plot(p[0][0], p[0][1], &#39;k.&#39;)</span>
    <span class="c1">#     plt.plot(p[1][0], p[1][1], &#39;r.&#39;)</span>

    <span class="c1"># Trim the centerline to remove the mirrored portions</span>
    <span class="n">start_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xs_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ys_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">end_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">]</span><span class="o">-</span><span class="n">xs_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">coords</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span><span class="o">-</span><span class="n">ys_rs</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Build the polygon mesh</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">start_idx</span><span class="p">,</span> <span class="n">end_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                      <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                      <span class="n">perp_aligned</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]])</span>

    <span class="n">perps_out</span> <span class="o">=</span> <span class="n">perp_aligned</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span>
    <span class="n">cl_resampled</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">r_</span><span class="p">[</span><span class="s1">&#39;1,2,0&#39;</span><span class="p">,</span> <span class="n">xs_rs</span><span class="p">,</span> <span class="n">ys_rs</span><span class="p">]</span>
    <span class="n">s_out</span> <span class="o">=</span> <span class="n">s</span><span class="p">[</span><span class="n">start_idx</span><span class="p">:</span><span class="n">end_idx</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">s</span><span class="p">[</span><span class="n">start_idx</span><span class="p">]</span>

    <span class="k">return</span> <span class="n">perps_out</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">cl_resampled</span><span class="p">,</span> <span class="n">s_out</span></div>


<div class="viewcode-block" id="mirror_line_ends"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.mirror_line_ends">[docs]</a><span class="k">def</span> <span class="nf">mirror_line_ends</span><span class="p">(</span><span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">npad</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Reflect both ends of a line.</span>

<span class="sd">    Reflects both ends of a line defined by x and y coordinates. The mirrored</span>
<span class="sd">    distance is set by npad, which refers to the number of vertices along the</span>
<span class="sd">    line to mirror.</span>

<span class="sd">    &quot;&quot;&quot;</span>
    <span class="c1"># Mirror the beginning of the line</span>
    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
    <span class="n">xs_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)),</span> <span class="n">xs</span><span class="p">))</span>
    <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
    <span class="n">ys_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)),</span> <span class="n">ys</span><span class="p">))</span>

    <span class="c1"># Mirror the end of the line</span>
    <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">xs_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xs_m</span><span class="p">,</span> <span class="n">xs_m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)))</span>
    <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
    <span class="n">ys_m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ys_m</span><span class="p">,</span> <span class="n">ys_m</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">xs_m</span><span class="p">,</span> <span class="n">ys_m</span></div>


<div class="viewcode-block" id="valleyline_mesh"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.valleyline_mesh">[docs]</a><span class="k">def</span> <span class="nf">valleyline_mesh</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="n">avg_chan_width</span><span class="p">,</span> <span class="n">buf_halfwidth</span><span class="p">,</span> <span class="n">grid_spacing</span><span class="p">,</span>
                    <span class="n">smoothing</span><span class="o">=</span><span class="mf">0.15</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Generate a mesh over an input river centerline.</span>

<span class="sd">    This function generates a mesh over an input river centerline. The mesh</span>
<span class="sd">    is generated across the valley, not just the channel width, in order to</span>
<span class="sd">    perform larger-scale spatial analyses. With the correct parameter</span>
<span class="sd">    combinations, it can also be used to generate a mesh for smaller-scale</span>
<span class="sd">    analysis, but it is optimized for larger and strange behavior may occur.</span>

<span class="sd">    Many plotting commands are commented out throughout this script as it&#39;s</span>
<span class="sd">    still somewhat in beta mode.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    coords :</span>
<span class="sd">        Nx2 list, tuple, or np.array of x,y coordinates. Coordinates MUST be</span>
<span class="sd">        in projected CRS for viable results.</span>
<span class="sd">    width_chan :</span>
<span class="sd">        estimated width. Units MUST correspond to those of the input</span>
<span class="sd">        coordinates</span>
<span class="sd">    buf_width :</span>
<span class="sd">        distance between centerline and left or right bufferline, in units of</span>
<span class="sd">        coords</span>
<span class="sd">    grid_spacing :</span>
<span class="sd">        fraction of input centerline length that should be used for smoothing</span>
<span class="sd">        to create the valley centerline  (between 0 and 1)</span>
<span class="sd">    smoothing :</span>
<span class="sd">        fraction of centerline length to use for smoothing window</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    lines :</span>
<span class="sd">        the &quot;perpendiculars&quot; to the centerline used to generate the mesh</span>
<span class="sd">    polys :</span>
<span class="sd">        coordinates of the polygons representing the grid cells of the mesh</span>

<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">find_cl_intersection_pts_and_distance</span><span class="p">(</span><span class="n">endpts</span><span class="p">,</span> <span class="n">cl</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute intersection points along centerline.</span>

<span class="sd">        Given a list of transect endpoints, this computes the intersection</span>
<span class="sd">        point along the centerline, and then returns the corresponding</span>
<span class="sd">        along-centerline distance to that point from the upstream boundary.</span>

<span class="sd">        End transects might not intersect the centerline. In these cases,</span>
<span class="sd">        we rely on the previous processing steps that artificially extended</span>
<span class="sd">        the centerline and simply drop the transects--effectively clipping</span>
<span class="sd">        the centerline to the first and last transect intersections.</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># int_pts = []</span>
        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">ie</span><span class="p">,</span> <span class="n">eps</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endpts</span><span class="p">):</span>
            <span class="n">tsect</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">eps</span><span class="p">)</span>
            <span class="n">int_pt</span> <span class="o">=</span> <span class="n">tsect</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">cl</span><span class="p">)</span>

            <span class="k">if</span> <span class="n">int_pt</span><span class="o">.</span><span class="n">coords</span> <span class="o">==</span> <span class="p">[]:</span>  <span class="c1"># There is no intersection</span>
                <span class="c1"># int_pts.append(None)</span>
                <span class="n">dist_to_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">continue</span>

            <span class="c1"># Project the intersection point to the centerline and return</span>
            <span class="c1"># the along-centerline distance of this point</span>
            <span class="n">dist_to_int</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">project</span><span class="p">(</span><span class="n">int_pt</span><span class="p">)))</span>

            <span class="c1"># int_pts.append(int_pt)</span>

        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">dist_to_int</span><span class="p">)</span>

        <span class="c1"># Now clip the distances, centerline, and endpoints where there were no intersections</span>
        <span class="n">no_ints</span> <span class="o">=</span> <span class="n">dist_to_int</span> <span class="o">==</span> <span class="kc">None</span>
        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="n">dist_to_int</span><span class="p">[</span><span class="o">~</span><span class="n">no_ints</span><span class="p">]</span>
        <span class="c1"># int_pts = [ip for i, ip in enumerate(int_pts) if no_ints[i] == False]</span>
        <span class="n">cl_clip</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])[</span><span class="o">~</span><span class="n">no_ints</span><span class="p">],</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])[</span><span class="o">~</span><span class="n">no_ints</span><span class="p">]))</span>
        <span class="n">ep_clip</span> <span class="o">=</span> <span class="p">[</span><span class="n">ep</span> <span class="k">for</span> <span class="n">iep</span><span class="p">,</span> <span class="n">ep</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">endpts</span><span class="p">)</span> <span class="k">if</span> <span class="n">no_ints</span><span class="p">[</span><span class="n">iep</span><span class="p">]</span> <span class="o">==</span> <span class="kc">False</span><span class="p">]</span>

        <span class="c1"># Reset the origin</span>
        <span class="n">dist_to_int</span> <span class="o">=</span> <span class="n">dist_to_int</span> <span class="o">-</span> <span class="n">dist_to_int</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>

        <span class="k">return</span> <span class="n">dist_to_int</span><span class="p">,</span> <span class="n">cl_clip</span><span class="p">,</span> <span class="n">ep_clip</span>


    <span class="k">def</span> <span class="nf">iterative_cl_pt_mapping</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">bufdists</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>

        <span class="n">mapper</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">lines</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span>

        <span class="n">old</span> <span class="o">=</span> <span class="n">cl</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">bd</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">bufdists</span><span class="p">):</span>

            <span class="n">new</span> <span class="o">=</span> <span class="n">shapely_offset_ls</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">bd</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>

            <span class="n">Co</span><span class="p">,</span> <span class="n">Ao</span><span class="p">,</span> <span class="n">so</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">curvars</span><span class="p">(</span><span class="n">old</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">old</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
            <span class="n">Cn</span><span class="p">,</span> <span class="n">An</span><span class="p">,</span> <span class="n">sn</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">curvars</span><span class="p">(</span><span class="n">new</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">new</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>

            <span class="n">Ao</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">Ao</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">An</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">insert</span><span class="p">(</span><span class="n">An</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

            <span class="n">distance</span><span class="p">,</span> <span class="n">path</span> <span class="o">=</span> <span class="n">fastdtw</span><span class="p">(</span><span class="n">Ao</span><span class="p">,</span> <span class="n">An</span><span class="p">,</span> <span class="n">dist</span><span class="o">=</span><span class="n">euclidean</span><span class="p">)</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

            <span class="n">mapper</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">new</span><span class="p">)</span>

            <span class="n">old</span> <span class="o">=</span> <span class="n">new</span>

        <span class="k">return</span> <span class="n">lines</span><span class="p">,</span> <span class="n">mapper</span>


    <span class="k">def</span> <span class="nf">get_transect_indices_along_buffered_lines</span><span class="p">(</span><span class="n">cl</span><span class="p">,</span> <span class="n">mapper</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a map of the index of each offset line mapped from the</span>
<span class="sd">        original centerline. Keys are original centerline indices; values</span>
<span class="sd">        are lists the length of number of offsets (i.e. length of bufdists).</span>
<span class="sd">        Really only the last entry in each value is needed, but keeping them</span>
<span class="sd">        all for developing/debugging purposes.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">pts</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])):</span>

            <span class="n">idx</span> <span class="o">=</span> <span class="n">i</span>
            <span class="n">idxlist</span> <span class="o">=</span> <span class="p">[</span><span class="n">idx</span><span class="p">]</span>

            <span class="k">for</span> <span class="n">m</span> <span class="ow">in</span> <span class="n">mapper</span><span class="p">:</span>
                <span class="n">m</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">m</span><span class="p">)</span>
                <span class="n">m_idx</span> <span class="o">=</span> <span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">m</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="n">idx</span><span class="p">))</span>  <span class="c1"># Get the most-downstrea</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">m_idx</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="nb">print</span><span class="p">(</span><span class="n">m_idx</span><span class="p">)</span>
                <span class="n">m_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">m_idx</span><span class="p">)</span>  <span class="c1"># Chooses the most downstream if multiple are available</span>
                <span class="n">idx</span> <span class="o">=</span> <span class="n">m</span><span class="p">[</span><span class="n">m_idx</span><span class="p">,</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">idxlist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">idx</span><span class="p">)</span>
            <span class="n">pts</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">idxlist</span>

        <span class="k">return</span> <span class="n">pts</span>
    

    <span class="k">def</span> <span class="nf">get_transect_endpoints_xy</span><span class="p">(</span><span class="n">lpts</span><span class="p">,</span> <span class="n">rpts</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Given dictionaries that map centerline points to indices along buffered</span>
<span class="sd">        left and right lines, this returns the endpoints of each transect.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">lpts</span><span class="p">)</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">rpts</span><span class="p">)</span>

        <span class="n">endpoints</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">lpts</span><span class="p">)):</span>
            <span class="n">lidx</span> <span class="o">=</span> <span class="n">lpts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ridx</span> <span class="o">=</span> <span class="n">rpts</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>

            <span class="n">lxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">llines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">lidx</span><span class="p">],</span> <span class="n">llines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">lidx</span><span class="p">])</span>
            <span class="n">rxy</span> <span class="o">=</span> <span class="p">(</span><span class="n">rlines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="n">ridx</span><span class="p">],</span> <span class="n">rlines</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="n">ridx</span><span class="p">])</span>
            <span class="n">endpoints</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">lxy</span><span class="p">,</span> <span class="n">rxy</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">endpoints</span>


    <span class="k">def</span> <span class="nf">shapely_offset_ls</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">side</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Just a wrapper around shapely&#39;s offset_linestring() function. That</span>
<span class="sd">        function adds little barbs sometimes to the end of the offset</span>
<span class="sd">        linestring. This function detects and removes those.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">offset</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">offset_linestring</span><span class="p">(</span><span class="n">ls</span><span class="p">,</span> <span class="n">dist</span><span class="p">,</span> <span class="n">side</span><span class="p">)</span>

        <span class="c1"># Look for barbs by finding abrupt angle changes</span>
        <span class="n">_</span><span class="p">,</span> <span class="n">A</span><span class="p">,</span> <span class="n">_</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">curvars</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">possibles</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">A</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mf">1.5</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># Threshold set at 1.5 radians</span>

        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">possibles</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">offset</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">st_idx</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">en_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="k">for</span> <span class="n">p</span> <span class="ow">in</span> <span class="n">possibles</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">p</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">st_idx</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">st_idx</span><span class="p">,</span> <span class="n">p</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">p</span> <span class="o">&gt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">/</span> <span class="mi">2</span><span class="p">:</span>
                    <span class="n">en_idx</span> <span class="o">=</span> <span class="nb">min</span><span class="p">(</span><span class="n">en_idx</span><span class="p">,</span> <span class="n">p</span><span class="p">)</span>
            <span class="n">offset</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="n">offset</span><span class="o">.</span><span class="n">coords</span><span class="p">[</span><span class="n">st_idx</span><span class="p">:</span><span class="n">en_idx</span><span class="p">])</span>

        <span class="c1"># elif len(possibles) == 1: # Determine if it&#39;s the upstream or downstream that&#39;s barbed</span>
        <span class="c1">#     if possibles[0] &gt; len(A)/2: # Downstream</span>
        <span class="c1">#         offset = LineString(zip(offset.coords.xy[0][:possibles[0]], offset.coords.xy[1][:possibles[0]]))</span>
        <span class="c1">#     else: # Upstream</span>
        <span class="c1">#         offset = LineString(zip(offset.coords.xy[0][possibles[0]:], offset.coords.xy[1][possibles[0]:]))</span>
        <span class="c1"># elif len(possibles) == 2:</span>
        <span class="c1">#     offset = LineString(zip(offset.coords.xy[0][possibles[0]:possibles[1]], offset.coords.xy[1][possibles[0]:possibles[1]]))</span>
        <span class="c1"># else:</span>
        <span class="c1">#     # import pdb; pdb.set_trace()</span>
        <span class="c1">#     raise Warning(&#39;Barbs could not be removed from centerline offset: dist={}, side={}.&#39;.format(dist,side))</span>

        <span class="k">return</span> <span class="n">offset</span>

    <span class="k">def</span> <span class="nf">mirror_lines</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">,</span> <span class="n">npad</span><span class="p">):</span>
        <span class="c1"># Mirror centerline manually since scipy fucks it up - only flip the axis that has the largest displacement</span>
        <span class="c1"># Mirroring done to avoid edge effects when smoothing</span>

        <span class="n">xs_o2</span><span class="p">,</span> <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">mirror_line_ends</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">,</span> <span class="n">npad</span><span class="p">)</span>
        <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_o</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
        <span class="n">xs_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">xs_o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)),</span> <span class="n">xs_o</span><span class="p">))</span>
        <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_o</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="n">npad</span><span class="p">])</span>
        <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">flipud</span><span class="p">(</span><span class="n">ys_o</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)),</span> <span class="n">ys_o</span><span class="p">))</span>

        <span class="n">diff_x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">xs_o</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">xs_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">xs_o2</span><span class="p">,</span> <span class="n">xs_o2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_x</span><span class="p">)))</span>
        <span class="n">diff_y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">diff</span><span class="p">(</span><span class="n">ys_o</span><span class="p">[</span><span class="o">-</span><span class="n">npad</span><span class="p">:][::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">ys_o2</span><span class="p">,</span> <span class="n">ys_o2</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">cumsum</span><span class="p">(</span><span class="n">diff_y</span><span class="p">)))</span>

        <span class="k">return</span><span class="p">(</span><span class="n">xs_o2</span><span class="p">,</span> <span class="n">ys_o2</span><span class="p">)</span>

    <span class="sd">&quot;&quot;&quot; Main function code begins here &quot;&quot;&quot;</span>
    <span class="c1"># obj = ind</span>
    <span class="c1"># coords = obj.centerline</span>
    <span class="c1"># avg_chan_width = obj.avg_chan_width</span>
    <span class="c1"># buf_halfwidth = obj.max_valley_width_pixels * obj.pixlen * 1.1</span>
    <span class="c1"># grid_spacing = avg_chan_width</span>
    <span class="c1"># smoothing = 0.1</span>

    <span class="k">if</span> <span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">coords</span><span class="p">)[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="mi">2</span> <span class="ow">and</span> <span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">4</span><span class="p">:</span>
        <span class="n">coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="n">coords</span><span class="p">)</span>

    <span class="c1"># Separate coordinates into xs and ys (o indicates original coordinates)</span>
    <span class="n">xs_o</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
    <span class="n">ys_o</span> <span class="o">=</span> <span class="n">coords</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>

    <span class="c1"># Set smoothing window size based on smoothing parameter and centerline length</span>
    <span class="n">s</span><span class="p">,</span> <span class="n">ds</span> <span class="o">=</span> <span class="n">cu</span><span class="o">.</span><span class="n">s_ds</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">)</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">smoothing</span> <span class="o">*</span> <span class="n">s</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">ds</span><span class="p">))</span>
    <span class="n">window_len</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">min</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs_o</span><span class="p">)</span><span class="o">/</span><span class="mi">5</span><span class="p">,</span> <span class="n">window_len</span><span class="p">))</span>  <span class="c1"># Smoothing window cannot be longer than 1/5 the centerline</span>
    <span class="k">if</span> <span class="n">window_len</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>  <span class="c1"># Window must be odd</span>
        <span class="n">window_len</span> <span class="o">=</span> <span class="n">window_len</span> <span class="o">+</span> <span class="mi">1</span>

    <span class="c1"># Extend the centerline ends to avoid boundary effects; we&#39;ll clip them later</span>
    <span class="n">xs_o2</span><span class="p">,</span> <span class="n">ys_o2</span> <span class="o">=</span> <span class="n">mirror_lines</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">,</span> <span class="n">window_len</span><span class="p">)</span>

    <span class="c1"># Smooth the coordinates before buffering</span>
    <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">xs_o2</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>
    <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">signal</span><span class="o">.</span><span class="n">savgol_filter</span><span class="p">(</span><span class="n">ys_o2</span><span class="p">,</span> <span class="n">window_length</span><span class="o">=</span><span class="n">window_len</span><span class="p">,</span> <span class="n">polyorder</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span>
                                 <span class="n">mode</span><span class="o">=</span><span class="s1">&#39;interp&#39;</span><span class="p">)</span>

    <span class="c1"># Create shapely LineString centerline</span>
    <span class="n">cl</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">([(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">)])</span>

    <span class="c1"># Simplify the linestring</span>
    <span class="n">npts</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">cl</span><span class="o">.</span><span class="n">length</span><span class="o">/</span><span class="n">avg_chan_width</span><span class="o">/</span><span class="mi">20</span><span class="p">),</span> <span class="mi">25</span><span class="p">)</span>
    <span class="n">tol</span> <span class="o">=</span> <span class="n">avg_chan_width</span><span class="o">/</span><span class="mi">100</span>
    <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
        <span class="n">cl2</span> <span class="o">=</span> <span class="n">cl</span><span class="o">.</span><span class="n">simplify</span><span class="p">(</span><span class="n">tol</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">cl2</span><span class="o">.</span><span class="n">coords</span><span class="p">)</span> <span class="o">&gt;</span> <span class="n">npts</span><span class="p">:</span>
            <span class="n">tol</span> <span class="o">=</span> <span class="n">tol</span> <span class="o">*</span> <span class="mf">1.1</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">break</span>

    <span class="c1"># Offset valley centerline for left and right valleylines</span>
    <span class="n">bdists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">buf_halfwidth</span><span class="p">,</span>
                         <span class="nb">min</span><span class="p">(</span><span class="nb">int</span><span class="p">(</span><span class="n">buf_halfwidth</span><span class="o">/</span><span class="n">avg_chan_width</span><span class="p">),</span> <span class="mi">25</span><span class="p">))</span>
    <span class="n">bdists</span> <span class="o">=</span> <span class="n">bdists</span><span class="p">[</span><span class="mi">1</span><span class="p">:]</span>

    <span class="c1"># Iteratively create offset lines and map each centerline index</span>
    <span class="n">llines</span><span class="p">,</span> <span class="n">lmap</span> <span class="o">=</span> <span class="n">iterative_cl_pt_mapping</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">bdists</span><span class="p">,</span> <span class="s1">&#39;left&#39;</span><span class="p">)</span>
    <span class="n">rlines</span><span class="p">,</span> <span class="n">rmap</span> <span class="o">=</span> <span class="n">iterative_cl_pt_mapping</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">bdists</span><span class="p">,</span> <span class="s1">&#39;right&#39;</span><span class="p">)</span>

    <span class="n">lpts</span> <span class="o">=</span> <span class="n">get_transect_indices_along_buffered_lines</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">lmap</span><span class="p">)</span>
    <span class="n">rpts</span> <span class="o">=</span> <span class="n">get_transect_indices_along_buffered_lines</span><span class="p">(</span><span class="n">cl2</span><span class="p">,</span> <span class="n">rmap</span><span class="p">)</span>

    <span class="n">endpts</span> <span class="o">=</span> <span class="n">get_transect_endpoints_xy</span><span class="p">(</span><span class="n">lpts</span><span class="p">,</span> <span class="n">rpts</span><span class="p">)</span>

    <span class="n">dists</span><span class="p">,</span> <span class="n">cl_clip</span><span class="p">,</span> <span class="n">ep_clip</span> <span class="o">=</span> <span class="n">find_cl_intersection_pts_and_distance</span><span class="p">(</span><span class="n">endpts</span><span class="p">,</span> <span class="n">cl2</span><span class="p">)</span>
    <span class="n">dists</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">d</span><span class="p">)</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">dists</span><span class="p">])</span>  <span class="c1"># avoid dtype(&#39;O&#39;) error in numpy.interp</span>

    <span class="c1"># Now build the interpolating functions</span>
    <span class="n">dists_to_interpolate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">dists</span><span class="p">),</span> <span class="n">grid_spacing</span><span class="p">)</span>
    <span class="n">xp_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>
    <span class="n">yp_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>
    <span class="n">xp_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>
    <span class="n">yp_r</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">ep</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="k">for</span> <span class="n">ep</span> <span class="ow">in</span> <span class="n">ep_clip</span><span class="p">])</span>

    <span class="c1"># Interpolate</span>
    <span class="n">x_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">xp_l</span><span class="p">)</span>
    <span class="n">y_left</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">yp_l</span><span class="p">)</span>
    <span class="n">x_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">xp_r</span><span class="p">)</span>
    <span class="n">y_right</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">interp</span><span class="p">(</span><span class="n">dists_to_interpolate</span><span class="p">,</span> <span class="n">dists</span><span class="p">,</span> <span class="n">yp_r</span><span class="p">)</span>

    <span class="c1"># # Plot the grid</span>
    <span class="c1"># plt.close(&#39;all&#39;)</span>
    <span class="c1"># plt.plot(cl.coords.xy[0], cl.coords.xy[1], &#39;--k&#39;)</span>
    <span class="c1"># plt.axis(&#39;equal&#39;)</span>
    <span class="c1"># for xl, yl, xr, yr in zip(x_left, y_left, x_right, y_right):</span>
    <span class="c1">#     plt.plot((xr, xl), (yr,yl))</span>

    <span class="c1"># Mesh is generated; export transects and polygons as shapely geometries</span>
    <span class="n">transects</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">,</span> <span class="n">xr</span><span class="p">,</span> <span class="n">yr</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x_left</span><span class="p">,</span> <span class="n">y_left</span><span class="p">,</span> <span class="n">x_right</span><span class="p">,</span> <span class="n">y_right</span><span class="p">):</span>
        <span class="n">transects</span><span class="o">.</span><span class="n">append</span><span class="p">(((</span><span class="n">xl</span><span class="p">,</span> <span class="n">yl</span><span class="p">),</span> <span class="p">(</span><span class="n">xr</span><span class="p">,</span> <span class="n">yr</span><span class="p">)))</span>

    <span class="c1"># The centerline was elongated to avoid boundary effects, so now we can</span>
    <span class="c1"># clip the transects to only those that are needed</span>
    <span class="n">cl_orig</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs_o</span><span class="p">,</span> <span class="n">ys_o</span><span class="p">))</span>
    <span class="n">intersects_cl</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineString</span><span class="p">(</span><span class="n">t</span><span class="p">)</span><span class="o">.</span><span class="n">intersects</span><span class="p">(</span><span class="n">cl_orig</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transects</span><span class="p">]</span>
    <span class="n">first_idx</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">intersects_cl</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span>
    <span class="n">last_idx</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">intersects_cl</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">argmax</span><span class="p">(</span><span class="n">intersects_cl</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">+</span> <span class="mi">1</span>  <span class="c1"># -1/+1 for explicitness</span>
    <span class="n">transects</span> <span class="o">=</span> <span class="p">[</span><span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">first_idx</span><span class="p">,</span> <span class="n">last_idx</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)]</span>

    <span class="c1"># Create mesh polygons</span>
    <span class="n">polys</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">transects</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
        <span class="n">polys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Polygon</span><span class="p">([</span><span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span> <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span>
                     <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">1</span><span class="p">],</span> <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">][</span><span class="mi">0</span><span class="p">],</span>
                     <span class="n">transects</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="mi">0</span><span class="p">]]))</span>

    <span class="c1"># Convert transects to shapely objects</span>
    <span class="n">transects</span> <span class="o">=</span> <span class="p">[</span><span class="n">LineString</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">for</span> <span class="n">t</span> <span class="ow">in</span> <span class="n">transects</span><span class="p">]</span>

    <span class="c1"># Clip the smooth centerline for return</span>
    <span class="n">xs_sm</span> <span class="o">=</span> <span class="n">xs_sm</span><span class="p">[</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:(</span><span class="nb">len</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">)</span><span class="o">-</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">ys_sm</span> <span class="o">=</span> <span class="n">ys_sm</span><span class="p">[</span><span class="n">window_len</span><span class="o">-</span><span class="mi">1</span><span class="p">:(</span><span class="nb">len</span><span class="p">(</span><span class="n">ys_sm</span><span class="p">)</span><span class="o">-</span><span class="n">window_len</span><span class="o">+</span><span class="mi">1</span><span class="p">)]</span>
    <span class="n">cl_smooth</span> <span class="o">=</span> <span class="n">LineString</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="n">xs_sm</span><span class="p">,</span> <span class="n">ys_sm</span><span class="p">))</span>

    <span class="k">return</span> <span class="n">transects</span><span class="p">,</span> <span class="n">polys</span><span class="p">,</span> <span class="n">cl_smooth</span></div>


<div class="viewcode-block" id="max_valley_width"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.max_valley_width">[docs]</a><span class="k">def</span> <span class="nf">max_valley_width</span><span class="p">(</span><span class="n">Imask</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Computes the maximum valley width of the input mask. Finds the single</span>
<span class="sd">    largest blob in the mask, fills its holes, then uses the distance transform</span>
<span class="sd">    to find the largest width.</span>

<span class="sd">    Parameters</span>
<span class="sd">    ----------</span>
<span class="sd">    Imask : np.array</span>
<span class="sd">        Binary mask from which the centerline was computed.</span>

<span class="sd">    Returns</span>
<span class="sd">    -------</span>
<span class="sd">    max_valley_width : float</span>
<span class="sd">        Maximum width of the channel belt, useful for computing a mesh. Units</span>
<span class="sd">        are pixels, so be careful to re-convert.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">Imask</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">largest_blobs</span><span class="p">(</span><span class="n">Imask</span><span class="p">,</span> <span class="n">nlargest</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s1">&#39;keep&#39;</span><span class="p">)</span>
    <span class="n">Imask</span> <span class="o">=</span> <span class="n">iu</span><span class="o">.</span><span class="n">fill_holes</span><span class="p">(</span><span class="n">Imask</span><span class="p">)</span>
    <span class="n">Idist</span> <span class="o">=</span> <span class="n">distance_transform_edt</span><span class="p">(</span><span class="n">Imask</span><span class="p">)</span>
    <span class="n">max_valley_width</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">Idist</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span>

    <span class="k">return</span> <span class="n">max_valley_width</span></div>


<div class="viewcode-block" id="compute_eBI"><a class="viewcode-back" href="../../../apiref/rivers.html#rivgraph.rivers.river_utils.compute_eBI">[docs]</a><span class="k">def</span> <span class="nf">compute_eBI</span><span class="p">(</span><span class="n">path_meshlines</span><span class="p">,</span> <span class="n">path_links</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;local&#39;</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    method can be &#39;local&#39; or &#39;avg&#39;</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">meshline_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">path_meshlines</span><span class="p">)</span>
    <span class="n">links_gdf</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">read_file</span><span class="p">(</span><span class="n">path_links</span><span class="p">)</span>

    <span class="k">if</span> <span class="s1">&#39;wid_adj&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Widths have not been appended to links yet; cannot compute eBI.&#39;</span><span class="p">)</span>

    <span class="n">inter</span> <span class="o">=</span> <span class="n">gpd</span><span class="o">.</span><span class="n">sjoin</span><span class="p">(</span><span class="n">meshline_gdf</span><span class="p">,</span> <span class="n">links_gdf</span><span class="p">,</span> <span class="n">op</span><span class="o">=</span><span class="s1">&#39;intersects&#39;</span><span class="p">)</span>

    <span class="c1"># Conver link widths to floats</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">wid_adj</span><span class="o">.</span><span class="n">values</span>
    <span class="n">widths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="p">)</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">widths</span><span class="p">])</span>

    <span class="c1"># Compute entropic braided index</span>
    <span class="n">mesh_index</span> <span class="o">=</span> <span class="n">meshline_gdf</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">values</span>
    <span class="n">eBI</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># entropic braided index</span>
    <span class="n">BI</span> <span class="o">=</span> <span class="p">[]</span> <span class="c1"># braided index</span>
    <span class="k">for</span> <span class="n">mi</span> <span class="ow">in</span> <span class="n">mesh_index</span><span class="p">:</span> <span class="c1">#1585</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">mi</span><span class="p">)</span>
        <span class="c1"># if mi == 1584:</span>
        <span class="c1">#     import pdb; pdb.set_trace()</span>
        <span class="c1"># First see if the mesh intersects the centerline</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">int_links</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">inter</span><span class="p">[</span><span class="s1">&#39;index_right&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">inter</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="n">mi</span><span class="p">)])</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">eBI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">BI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># A second check to handle strange cases</span>
        <span class="n">bi_section</span> <span class="o">=</span> <span class="n">int_links</span><span class="o">.</span><span class="n">size</span>
        <span class="k">if</span> <span class="n">bi_section</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">eBI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="n">BI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span>

        <span class="c1"># This is because numpy returns an array when multiple values returned, and an int when a single value is returned</span>
        <span class="k">if</span> <span class="n">int_links</span><span class="o">.</span><span class="n">size</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
            <span class="n">int_links</span> <span class="o">=</span> <span class="p">[</span><span class="n">int_links</span><span class="o">.</span><span class="n">tolist</span><span class="p">()]</span>

        <span class="k">if</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;avg&#39;</span><span class="p">:</span>
            <span class="c1"># Method 1: use the average link width</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="n">widths</span><span class="p">[</span><span class="n">int_links</span><span class="p">]</span>

        <span class="k">elif</span> <span class="n">method</span> <span class="o">==</span> <span class="s1">&#39;local&#39;</span><span class="p">:</span>

            <span class="c1"># Method 2: use the local channel width</span>
            <span class="n">ws</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">il</span> <span class="ow">in</span> <span class="n">int_links</span><span class="p">:</span>
                <span class="c1"># print(links_gdf.id.values[il])</span>
                <span class="n">meshline</span> <span class="o">=</span> <span class="n">meshline_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">mi</span><span class="p">]</span>
                <span class="n">rivline</span> <span class="o">=</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">il</span><span class="p">]</span>
                <span class="n">int_pt</span> <span class="o">=</span> <span class="n">rivline</span><span class="o">.</span><span class="n">intersection</span><span class="p">(</span><span class="n">meshline</span><span class="p">)</span>

                <span class="c1"># If there are multiple intersection points along the same link, use the link&#39;s average width</span>
                <span class="k">if</span> <span class="nb">type</span><span class="p">(</span><span class="n">int_pt</span><span class="p">)</span> <span class="o">!=</span> <span class="n">shapely</span><span class="o">.</span><span class="n">geometry</span><span class="o">.</span><span class="n">point</span><span class="o">.</span><span class="n">Point</span><span class="p">:</span>
                    <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">widths</span><span class="p">[</span><span class="n">il</span><span class="p">])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">int_id</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">argmin</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rivline</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">-</span><span class="n">int_pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="o">+</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">rivline</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">-</span><span class="n">int_pt</span><span class="o">.</span><span class="n">coords</span><span class="o">.</span><span class="n">xy</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span><span class="p">))</span>

                    <span class="c1"># Converting from string to float</span>
                    <span class="n">ws_il</span> <span class="o">=</span> <span class="n">links_gdf</span><span class="o">.</span><span class="n">wid_pix</span><span class="o">.</span><span class="n">values</span><span class="p">[</span><span class="n">il</span><span class="p">]</span>
                    <span class="n">ws_il</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="nb">float</span><span class="p">(</span><span class="n">w</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">,</span><span class="s1">&#39;&#39;</span><span class="p">))</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ws_il</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39; &#39;</span><span class="p">)</span> <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">])</span>
                    <span class="n">ws</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ws_il</span><span class="p">[</span><span class="n">int_id</span><span class="p">])</span>

        <span class="n">ws</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">w</span> <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">ws</span> <span class="k">if</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">])</span> <span class="c1"># Remove links of 0 width -- should determine why these are zero, probably due to computing widths on the original mask instead of the pre-processed one...</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="n">ws</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">ws</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">any</span><span class="p">(</span><span class="n">probs</span> <span class="o">==</span> <span class="mi">0</span><span class="p">):</span>
            <span class="k">raise</span> <span class="ne">RuntimeError</span><span class="p">(</span><span class="s1">&#39;Transect </span><span class="si">{}</span><span class="s1"> intersects a link of width 0.&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">mi</span><span class="p">))</span>

        <span class="n">H</span> <span class="o">=</span> <span class="o">-</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">probs</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">log2</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span>
        <span class="n">ebi_section</span> <span class="o">=</span> <span class="mi">2</span><span class="o">**</span><span class="n">H</span>
        <span class="n">eBI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">ebi_section</span><span class="p">)</span>
        <span class="n">BI</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">bi_section</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">eBI</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">BI</span><span class="p">)</span></div>
</pre></div>

           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2020, J. Schwenk &amp; J. Hariharan.</p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>